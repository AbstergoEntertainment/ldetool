# ldetool means line data extraction tool
Primary use case: fast yet simple log parsing.

### Preamble

There's a traditional solution for this kind of tasks: regular expression with capture groups. But it has numerous generic and Go-specific disadvantages:

1. Syntax. Hard to debug and read.
2. Speed. While simple non-capturing regular expressions can be speedy, they quickly becomes slow as the complexity of the regular expression grows
3. They are overpowered for simple log parsing. In our experience with log processing we are not looking for patterns within the line. Usually our data is well structured and it is easier to think (and compute!) in terms of bounds and separators. And if the data is not well structured then it is a good idea to make it so, just for the sake of readability.
4. Go regular expressions are slow. Go regular expressions with group capture are even slower. Read basic explanation on performance [here](PERFORMANCE.md)

### Approach proposed.

What would we need?

* Take data from the current position right to the certain bound (`]` in example)
	```
	1234] UserAgent[....]
	```
* Take data from the current position right to the certain bound or take the rest if not found (take value 12 in the first line and value 13 in the second)
	```
	[2017-08-12T12:05:37] val=12
	[2017-08-12T12:05:37] val=13,hidden=1
	```
* Take the rest
* Look for certain bound and pass it (` UserAgent[` in example)
	```
	UserAgent[....]
	```
* Check if the rest starts with certain string or char (`value=` in example)
	```
	value=123
	```
* Pass first N symbols of the rest
* Limit all kind of lookups (search and pass string/character, bounds for data taker) with first N characters
* Optional subgroups.

#### Syntax
See [more details](TOOL_RULES.md) on parsing rules

```perl
# filename: Line.lde
Line =
  _ ' '                                  # Pass to the space (x20) character
  Time(string) ']'                       # Take everything as a record for Time right to ']' character
  ^" FETCH_EVENTS "                      # Current rest must starts with " FETCH_EVENTS " string
  ^"first=" First(uint8) ' '             # The rest must starts with "first=" characters, then take the rest until ' ' as uint8
                                         # under the name of First
  ^"format=" Format(string) ' '          # Take format id
  ^"responseTime=" Duration(string) ' '   # Take mandatory response time
  ?Hidden (^"hidden=" Value(uint8) ' ')  # Optionally look for "hidden=\d+"
  ^"user_agent=\"" UserAgent(string) '"' # User agent data
  ^"country=" Country(string) ?? ' ';    # Take data as country to the rest or right to the first space character
```

And what would like to have from it:
* Code must be easy for comprehension and manual extension
* There should be as least dependencies as possible..
* Error messages should be helpful, i.e. mismatch cases must be easy to spot via error messages.
* Extracted data must be accessible via names (using struct fields)
* Unneccessary allocations should be avoided. For instance, when scanning logs we use []byte buffer as a temporary storage. Usually these fields only needed within the lifetime of current line, so extracted substrings better be []byte themselves, not strings

And now use ldetool:
1. Save rule for [Line](#syntax-for-extraction-of-needed-data-for-these-particular-lines) into parsing.scripts file
2. Generate parsing_scripts_lde.go file using
    ```bash
	ldetool generate --package main parsing.scripts
	```
	and move it somewhere. The code will look like
	```go
	package main // We set the package name to main in the call of the utility

	import (
		....
    )

	var countryEq = []byte("country=")
	var ....
	....

	// Line autogenerated parser
	type Line struct {
		rest     []byte
		Time     []byte
		First    uint8
		Format   []byte
		Duration []byte
		Hidden   struct {
			Valid bool
			Value uint8
		}
		UserAgent []byte
		Country   []byte
	}

	// Parse autogenerated method of line
	func (p *Line) Parse(line []byte) (bool, error) {
		....
	}

	func (p *line) GetHiddenValue() (res uint8) {
		if !p.Hidden.Valid {
			return
		}
		return p.Hidden.Value
	}


    ```

We have done all preparations. Now use generated line parser.

``` go
package main

import (
	"bufio"
	"os"
	"fmt"
)

func main() {
	parser := &Line{}
	reader := bufio.NewReader(os.Stdin)
	scanner := bufio.NewScanner(reader)
	lbuf := &bytes.Buffer{}
	for scanner.Scan() {
		if ok, err := parser.Parse(scanner.Bytes()); !ok {
			continue
		} else if err != nil {
			fmt.Fprintf(os.Stderr, "`\033[1m%s\033[0m` on parsing>>\033[1m%s\033[0m\n", err, scanner.Text())
			continue
		}
		lbuf.Reset()

		fmt.Printf("%s\t%d\t%s\t%s\t%d\t%s\t%s\n",
			string(parser.Time),
			parser.First,
			string(parser.Format),
			string(parser.Duration),
			parser.GetHiddenValue(),
			string(parser.UserAgent),
			string(parser.Country),
		)
	}
}
```
Take care of fmt.Printf usage above. I don't mean it is OK to use fmt.Printf. It is not. All efforts made so far all were for speed purposes, the fmt.Printf basically defeats all of them. You should consider using other tools, that will provide better output performance.
Our typical usecase was to parse lines and put extracted data into clickhouse using [these](https://github.com/sirkon/ch-encode) [tools](https://github.com/sirkon/ch-insert).
