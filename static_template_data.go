
package main

var staticTemplatesData = map[string]string{
"at_end": "\n// Check if the rest is empty\nif len(p.rest) > 0 {\nreturn false, {{ if .Serious }}fmt.Errorf(\"Rest must be empty, not `\\033[1m%s\\033[0m`\", string(p.rest)){{else}}nil{{end}}\n}",
"close_option_scope": ";p.{{.Name}} = true\n{{ if .WasAbandoned }}{{.ScopeLabel}}:\n{{end}}",
"close_scope": "};",
"decode_float": "if tmpFloat, err = strconv.ParseFloat(*(*string)(unsafe.Pointer(&{{.Source}})), {{ .Bits }}); err != nil {\n    return false, fmt.Errorf(\"Error parsing \\033[1m%s\\033[0m value as {{ .Type }} for field \\033[1m{{ .Dest }}\\033[0m: %s\", string({{.Source}}), err)\n}\np.{{.Dest}} = float{{.Bits}}(tmpFloat);",
"decode_int": "if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&{{ .Source }})), 10, {{ .Bits }}); err != nil {\n    return false, fmt.Errorf(\"Error parsing \\033[1m%s\\033[0m value as {{ .Type }} for field \\033[1m{{ .Dest }}\\033[0m: %s\", string({{ .Source }}), err)\n}\np.{{.Dest}} = int{{.Bits}}(tmpInt);",
"decode_string": "p.{{.Dest}} = {{.Source}};",
"decode_uint": "if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&{{.Source}})), 10, {{ .Bits }}); err != nil {\n    return false, fmt.Errorf(\"Error parsing \\033[1m%s\\033[0m value as {{ .Type }} for field \\033[1m{{ .Dest }}\\033[0m: %s\", string({{.Source}}), err)\n}\np.{{.Dest}} = uint{{.Bits}}(tmpUint);",
"getter": "\n// Get{{.LongName}} retrieves optional value for {{.LongName}}.Name\nfunc (p *{{.ParserName}}) Get{{.LongName}}() (res {{.Type}}) {\n\t if {{ range $index, $data := .Accesses }}{{ if $index }}||{{end}}!p.{{$data}}.Valid{{end}} {\n  \t return\n\t };\n\t return p.{{.Access}}.{{.Name}}\n}\n",
"head_char": "\n// Checks if the rest starts with {{.Char}} symbol and pass it\nif len(p.rest) > 0 && p.rest[0] == {{.Char}} {\n   p.rest = p.rest[1:]\n} else {\n{{if .Namespace}}p.{{.Namespace}}.Valid = false; goto {{.ScopeLabel}}{{else}}return false, {{ if .Serious }}fmt.Errorf(\"The rest (\\033[1m%s\\033[0m) doesn't start with `\\033[1m%s\\033[0m`\", string(p.rest), {{.Char}}){{else}}nil{{end}};{{end}}\n}",
"head_char_maybe": "\n// Checks if the rest starts with {{.Char}} symbol and pass it if matched\nif len(p.rest) > 0 && p.rest[0] == {{.Char}} {\n   p.rest = p.rest[1:]\n}",
"head_string": "\n// Checks if the rest starts with {{.ConstValue}} and pass it\nif bytes.HasPrefix(p.rest, {{.ConstName}}) {\n   p.rest = p.rest[len({{.ConstName}}):]\n} else {\n{{if .Namespace}}p.{{.Namespace}}.Valid = false; goto {{.ScopeLabel}}{{else}}return false, {{ if .Serious }}fmt.Errorf(\"The rest (\\033[1m%s\\033[0m) doesn't start with `\\033[1m%s\\033[0m`\", string(p.rest), {{.ConstName}}){{else}}nil{{end}};{{end}}\n}",
"head_string_maybe": "\n// Checks if the rest starts with {{.ConstValue}} and pass it if matched\nif bytes.HasPrefix(p.rest, {{.ConstName}}) {\n   p.rest = p.rest[len({{.ConstName}}):]\n}",
"lookup_bounded_char": "\n// Looking for {{ .Char }} symbol from {{.Lower}} until {{.Upper}} symbols of the rest and then pass it\nif len(p.rest) < {{.Upper}} {\n{{if .Namespace}}p.{{.Namespace}}.Valid = false; goto {{.ScopeLabel}}{{else}}return false, {{ if.Serious }}fmt.Errorf(\"Requested lookup in {{.Lower}}..%d-th symbols of the rest while only %s left\", {{.Upper}}-1, len(p.rest)){{else}}nil{{end}};{{end}}\n}\npos = bytes.IndexByte(p.rest[{{.Lower}}:{{.Upper}}], {{ .Char }});\nif pos >= 0 {\n    p.rest = p.rest[pos + {{.Lower}} + 1:]\n} else {\n{{if .Namespace}}p.{{.Namespace}}.Valid = false; goto {{.ScopeLabel}}{{else}}return false, {{ if .Serious }}fmt.Errorf(\"Cannot find `\\033[1m%c\\033[0m` in `\\033[1m%s\\033[0m`\", {{.Char}}, string(p.rest[{{.Lower}}:{{.Upper}}])){{else}}nil{{end}};{{end}}\n}",
"lookup_bounded_char_noerror": "\n// Looking for {{ .Char }} symbol from {{.Lower}} until {{.Upper}} symbols of the rest and then pass it\nif len(p.rest) < {{.Upper}} {\n{{if .Namespace}}p.{{.Namespace}}.Valid = false; goto {{.ScopeLabel}}{{else}}return false, {{ if.Serious }}fmt.Errorf(\"Requested lookup in {{.Lower}}..%d-th symbols of the rest while only %s left\", {{.Upper}}-1, len(p.rest)){{else}}nil{{end}};{{end}}\n}\npos = bytes.IndexByte(p.rest[{{.Lower}}:{{.Upper}}], {{ .Char }});\nif pos >= 0 {\n    p.rest = p.rest[pos + {{.Lower}} + 1:]\n}",
"lookup_bounded_string": "\n// Looking for {{ .ConstValue }} from {{.Lower}} until {{.Upper}} symbols of the rest and then pass it\nif len(p.rest) < {{.Upper}} {\n{{if .Namespace}}p.{{.Namespace}}.Valid = false; goto {{.ScopeLabel}}{{else}}return false, {{ if.Serious }}fmt.Errorf(\"Requested lookup in {{.Lower}}..%d-th symbols of the rest while only %d left\", {{.Upper}}, len(p.rest)){{else}}nil{{end}};{{end}}\n}\npos = bytes.Index(p.rest[{{.Lower}}:{{.Upper}}], {{ .ConstName }});\nif pos >= 0 {\n    p.rest = p.rest[pos + {{.Lower}} + len({{.ConstName}}):]\n} else {\n{{if .Namespace}}p.{{.Namespace}}.Valid = false; goto {{.ScopeLabel}}{{else}}return false, {{ if .Serious }}fmt.Errorf(\"Cannot find `\\033[1m%s\\033[0m` in `\\033[1m%s\\033[0m`\", {{.ConstName}}, string(p.rest[{{.Lower}}:{{.Upper}}])){{else}}nil{{end}};{{end}}\n}",
"lookup_bounded_string_noerror": "\n// Looking for {{ .ConstValue }} from {{.Lower}} until {{.Upper}} symbols of the rest and then pass it if found\nif len(p.rest) < {{.Upper}} {\n{{if .Namespace}}p.{{.Namespace}}.Valid = false; goto {{.ScopeLabel}}{{else}}return false, {{ if.Serious }}fmt.Errorf(\"Requested lookup in {{.Lower}}..%d-th symbols of the rest while only %d left\", {{.Upper}}-1, len(p.rest)){{else}}nil{{end}};{{end}}\n}\npos = bytes.Index(p.rest[{{.Lower}}:{{.Upper}}], {{ .ConstName }});\nif pos >= 0 {\n    p.rest = p.rest[pos + {{.Lower}} + len({{.ConstName}}):]\n}",
"lookup_char": "\n// Looking for {{ .Char }} symbol and then pass it\npos = bytes.IndexByte(p.rest, {{ .Char }});\nif pos >= 0 {\n    p.rest = p.rest[pos + 1:]\n} else {\n{{ if .Namespace }}p.{{.Namespace}}.Valid = false; goto {{.ScopeLabel}}{{else}}return false, {{ if .Serious }}fmt.Errorf(\"Cannot find `\\033[1m%c\\033[0m` in `\\033[1m%s\\033[0m`\", {{.Char}}, string(p.rest)){{else}}nil{{end}};{{end}}\n}",
"lookup_char_noerror": "\n// Looking for {{ .Char }} symbol and then pass it if found\npos = bytes.IndexByte(p.rest, {{ .Char }});\nif pos >= 0 {\n    p.rest = p.rest[pos + 1:]\n}",
"lookup_limited_char": "\n// Looking for {{ .Char }} symbol in first {{.Upper}} symbols of the rest and then pass it\nif len(p.rest) < {{.Upper}} {\n{{ if .Namespace }}p.{{.Namespace}}.Valid = false; goto {{.ScopeLabel}}{{else}}return false, {{ if.Serious }}fmt.Errorf(\"Requested lookup in first {{.Upper}} symbols of the rest while only %d left\", len(p.rest)){{else}}nil{{end}};{{end}}\n}\npos = bytes.IndexByte(p.rest[:{{.Upper}}], {{ .Char }});\nif pos >= 0 {\n    p.rest = p.rest[pos + 1:]\n} else {\n{{ if .Namespace }}p.{{.Namespace}}.Valid = false; goto {{.ScopeLabel}}{{else}}return false, {{ if .Serious }}fmt.Errorf(\"Cannot find `\\033[1m%c\\033[0m` in `\\033[1m%s\\033[0m`\", {{.Char}}, string(p.rest[:{{.Upper}}])){{else}}nil{{end}};{{end}}\n}",
"lookup_limited_char_noerror": "\n// Looking for {{ .Char }} symbol in first {{.Upper}} symbols of the rest and then pass it if found\nif len(p.rest) < {{.Upper}} {\n{{ if .Namespace }}p.{{.Namespace}}.Valid = false; goto {{.ScopeLabel}}{{else}}return false, {{ if.Serious }}fmt.Errorf(\"Requested lookup in first {{.Upper}} symbols of the rest while only %s left\", len(p.rest)){{else}}nil{{end}};{{end}}\n}\npos = bytes.IndexByte(p.rest[:{{.Upper}}], {{ .Char }});\nif pos >= 0 {\n    p.rest = p.rest[pos + 1:]\n}",
"lookup_limited_string": "\n// Looking for {{ .ConstValue }} in first {{.Upper}} symbols of the rest and then pass it\nif len(p.rest) < {{.Upper}} {\n{{if .Namespace}}p.{{.Namespace}}.Valid = false; goto {{.ScopeLabel}}{{else}}return false, {{ if.Serious }}fmt.Errorf(\"Requested lookup in first {{.Upper}} symbols of the rest while only %d left\", len(p.rest)){{else}}nil{{end}};{{end}}\n}\npos = bytes.Index(p.rest[:{{.Upper}}], {{ .ConstName }});\nif pos >= 0 {\n    p.rest = p.rest[pos + len({{.ConstName}}):]\n} else {\n{{if .Namespace }}p.{{.Namespace}}.Valid = false; goto {{.ScopeLabel}}{{else}}return false, {{ if .Serious }}fmt.Errorf(\"Cannot find `\\033[1m%s\\033[0m` in `\\033[1m%s\\033[0m`\", {{.ConstName}}, string(p.rest[:{{.Upper}}])){{else}}nil{{end}};{{end}}\n}",
"lookup_limited_string_noerror": "\n// Looking for {{ .ConstValue }} in first {{.Upper}} symbols of the rest and then pass it if found\nif len(p.rest) < {{.Upper}} {\n{{if .Namespace}}p.{{.Namespace}}.Valid = false; goto {{.ScopeLabel}}{{else}}return false, {{ if.Serious }}fmt.Errorf(\"Requested lookup in first {{.Upper}} symbols of the rest while only %s left\", len(p.rest)){{else}}nil{{end}};{{end}}\n}\npos = bytes.Index(p.rest[:{{.Upper}}], {{ .ConstName }});\nif pos >= 0 {\n    p.rest = p.rest[pos + len({{.ConstName}}):]\n}",
"lookup_string": "\n// Looking for {{ .ConstValue }} and then pass it\npos = bytes.Index(p.rest, {{ .ConstName }});\nif pos >= 0 {\n    p.rest = p.rest[pos + len({{.ConstName}}):]\n} else {\n{{if .Namespace}}p.{{.Namespace}}.Valid = false; goto {{.ScopeLabel}}{{else}}return false, {{ if .Serious }}fmt.Errorf(\"Cannot find `\\033[1m%s\\033[0m` in `\\033[1m%s\\033[0m`\", {{.ConstName}}, string(p.rest)){{else}}nil{{end}};{{end}}\n}",
"lookup_string_noerror": "\n// Looking for {{ .ConstValue }} and then pass it if found\npos = bytes.Index(p.rest, {{ .ConstName }});\nif pos >= 0 {\n    p.rest = p.rest[pos + len({{.ConstName}}):]\n}",
"open_option": "{{.Name}} struct {\n   Valid bool;",
"parser_body": "// Parse autogenerated method of {{.ParserName}}\nfunc (p *{{.ParserName}}) Parse(line []byte) (bool, error) {\n   {{ range .Vars }} var {{.Name}} {{.Type}};{{end}}\n   p.rest = line\n   {{.Parser}}\n   return true, nil\n}\n",
"parser_code": "package {{ .PkgName }}\n\n{{ if .Imports }}import (\n{{ range .Imports }}{{.Name}} \"{{.Path}}\"\n{{end}}\n){{end}}\n\n{{range $name, $value := .Consts }}var {{$name}} = []byte({{$value}});{{end}}\n\n\n{{.Struct}}\n\n{{.Parser}}\n\n{{.Getters}}\n",
"pass_n_items": "\n// Cut out first N items from the rest\nif len(p.rest) >= {{.Upper}} {\n p.rest = p.rest[{{.Upper}}:]\n} else {\n{{if .Namespace}}p.{{.Namespace}}.Valid = false; goto {{.ScopeLabel}}{{else}}return false, {{ if .Serious }}fmt.Errorf(\"Cannot cut out first {{.Upper}} symbols from the rest: it is shorter (%d)\", len(p.rest)){{else}}nil{{end}};{{end}}\n}",
"soft_exit": "return false, nil",
"struct_body": "// {{.ParserName}} autogenerated parser\ntype {{.ParserName}} struct {\nrest []byte\n{{.Struct}}\n}\n",
"struct_field": "{{.Name}} {{.Type}};",
"take_before_bounded_char": "\n// Put data before {{ .Char }} into {{ .Dest }} with limited to {{.Lower}}..{{.Upper}} symbol range boundary lookup\nif len(p.rest) < {{.Upper}} {\n{{if .Namespace}}p.{{.Namespace}}.Valid = false; goto {{.ScopeLabel}}{{else}}return false, {{ if.Serious }}fmt.Errorf(\"Requested lookup in first {{.Upper}} symbols to bound value for {{.Dest}} of the rest while only %d left\", len(p.rest)){{else}}nil{{end}};{{end}}\n}\nif pos = bytes.IndexByte(p.rest[{{.Lower}}:{{.Upper}}], {{ .Char }}); pos >= 0 {\n   {{ if .UseTmp }}tmp = p.rest[:{{.Lower}}+pos]\n     {{ call .Decoder \"tmp\"  .Dest }}{{else}} {{ call .Decoder ( printf \"p.rest[:%d+pos]\" .Lower )  .Dest }}{{end}}\n  p.rest = p.rest[pos+{{.Lower}}+1:]\n} else {\n{{if .Namespace}}p.{{.Namespace}}.Valid = false; goto {{.ScopeLabel}}{{else}}return false, {{ if .Serious }}fmt.Errorf(\"Cannot find `\\033[1m%c\\033[0m` in `\\033[1m%s\\033[0m` to bound data for field {{.Dest}}\", {{.Char}}, string(p.rest[{{.Lower}}:{{.Upper}}])){{else}}nil{{end}};{{end}}\n}",
"take_before_bounded_char_or_rest": "\n// Put data before {{ .Char }} into {{ .Dest }} with limited to {{.Lower}}..{{.Upper}} symbols boundary lookup or everything to the very rest if not found\nif len(p.rest) < {{.Upper}} {\n{{if .Namespace}}p.{{.Namespace}}.Valid = false; goto {{.ScopeLabel}}{{else}}return false, {{ if.Serious }}fmt.Errorf(\"Requested lookup in first {{.Upper}} symbols to bound value for {{.Dest}} of the rest while only %d left\", len(p.rest)){{else}}nil{{end}};{{end}}\n}\nif pos = bytes.IndexByte(p.rest[{{.Lower}}:{{.Upper}}], {{ .Char }}); pos >= 0 {\n  tmp = p.rest[:pos+{{.Lower}}]\n  p.rest = p.rest[pos+{{.Lower}}+1:]\n} else {\n  tmp = p.rest\n  p.rest = p.rest[len(p.rest):]\n}\n{{ call .Decoder \"tmp\"  .Dest }}\n",
"take_before_bounded_string": "\n// Put data before {{ .ConstValue }} into {{ .Dest }} with limited to {{.Lower}}..{{.Upper}} symbol range boundary lookup\nif len(p.rest) < {{.Upper}} {\n{{if .Namespace}}p.{{.Namespace}}.Valid = false; goto {{.ScopeLabel}}{{else}}return false, {{ if.Serious }}fmt.Errorf(\"Requested lookup in first {{.Upper}} symbols to bound value for {{.Dest}} of the rest while only %d left\", len(p.rest)){{else}}nil{{end}};{{end}}\n}\nif pos = bytes.Index(p.rest[{{.Lower}}:{{.Upper}}], {{ .ConstName }}); pos >= 0 {\n   {{ if .UseTmp }}tmp = p.rest[:{{.Lower}}+pos]\n     {{ call .Decoder \"tmp\"  .Dest }}{{else}} {{ call .Decoder ( printf \"p.rest[:%d+pos]\" .Lower )  .Dest }}{{end}}\n  p.rest = p.rest[pos+{{.Lower}}+len({{.ConstName}}):]\n} else {\n{{if .Namespace}}p.{{.Namespace}}.Valid = false; goto {{.ScopeLabel}}{{else}}return false, {{ if .Serious }}fmt.Errorf(\"Cannot find `\\033[1m%s\\033[0m` in `\\033[1m%s\\033[0m` to bound data for field {{.Dest}}\", {{.ConstName}}, string(p.rest[{{.Lower}}:{{.Upper}}])){{else}}nil{{end}};{{end}}\n}",
"take_before_bounded_string_or_rest": "\n// Put data before {{ .ConstValue }} into {{ .Dest }} with limited to {{.Lower}}..{{.Upper}} symbols boundary lookup or everything to the very rest if not found\nif len(p.rest) < {{.Upper}} {\n{{if .Namespace}}p.{{.Namespace}}.Valid = false; goto {{.ScopeLabel}}{{else}}return false, {{ if.Serious }}fmt.Errorf(\"Requested lookup in first {{.Upper}} symbols to bound value for {{.Dest}} of the rest while only %d left\", len(p.rest)){{else}}nil{{end}};{{end}}\n}\nif pos = bytes.Index(p.rest[{{.Lower}}:{{.Upper}}], {{ .ConstName }}); pos >= 0 {\n  tmp = p.rest[:pos+{{.Lower}}]\n  p.rest = p.rest[pos+{{.Lower}}+len({{.ConstName}}):]\n} else {\n  tmp = p.rest\n  p.rest = p.rest[len(p.rest):]\n}\n{{ call .Decoder \"tmp\"  .Dest }}\n",
"take_before_char": "\n// Put data before {{ .Char }} into {{ .Dest }}\nif pos = bytes.IndexByte(p.rest, {{ .Char }}); pos >= 0 {\n  {{ if .UseTmp }}tmp = p.rest[:pos]\n  {{ call .Decoder \"tmp\"  .Dest }}{{else}}{{ call .Decoder \"p.rest[:pos]\"  .Dest }}{{end}}\n  p.rest = p.rest[pos+1:]\n} else {\n{{if .Namespace}}p.{{.Namespace}}.Valid = false; goto {{.ScopeLabel}}{{else}}return false, {{ if .Serious }}fmt.Errorf(\"Cannot find `\\033[1m%c\\033[0m` in `\\033[1m%s\\033[0m` to bound data for field {{.Dest}}\", {{.Char}}, string(p.rest)){{else}}nil{{end}};{{end}}\n}",
"take_before_char_or_rest": "\n// Put data before {{ .Char }} into {{ .Dest }} if found otherwise take to the end\nif pos = bytes.IndexByte(p.rest, {{ .Char }}); pos >= 0 {\n  tmp = p.rest[:pos]\n  p.rest = p.rest[pos+1:]\n} else {\n  tmp = p.rest\n  p.rest = p.rest[len(p.rest):]\n}\n{{ call .Decoder \"tmp\"  .Dest }}\n",
"take_before_limited_char": "\n// Put data before {{ .Char }} into {{ .Dest }} with limited to {{.Upper}} symbols boundary lookup\nif len(p.rest) < {{.Upper}} {\n{{if .Namespace}}p.{{.Namespace}}.Valid = false; goto {{.ScopeLabel}}{{else}}return false, {{ if.Serious }}fmt.Errorf(\"Requested lookup in first {{.Upper}} symbols to bound value for {{.Dest}} of the rest while only %d left\", len(p.rest)){{else}}nil{{end}};{{end}}\n}\nif pos = bytes.IndexByte(p.rest[:{{.Upper}}], {{ .Char }}); pos >= 0 {\n  {{ if .UseTmp }}tmp = p.rest[:pos]\n  {{ call .Decoder \"tmp\"  .Dest }}{{else}}{{ call .Decoder \"p.rest[:pos]\"  .Dest }}{{end}}\n  p.rest = p.rest[pos+1:]\n} else {\n{{if .Namespace}}p.{{.Namespace}}.Valid = false; goto {{.ScopeLabel}}{{else}}return false, {{ if .Serious }}fmt.Errorf(\"Cannot find `\\033[1m%c\\033[0m` in `\\033[1m%s\\033[0m` to bound data for field {{.Dest}}\", {{.Char}}, string(p.rest[:{{.Upper}}])){{else}}nil{{end}};{{end}}\n}",
"take_before_limited_char_or_rest": "\n// Put data before {{ .Char }} into {{ .Dest }} with limited to {{.Upper}} symbols boundary lookup or everything to the very rest if not found\nif len(p.rest) < {{.Upper}} {\n{{if .Namespace}}p.{{.Namespace}}.Valid = false; goto {{.ScopeLabel}}{{else}}return false, {{ if.Serious }}fmt.Errorf(\"Requested lookup in first {{.Upper}} symbols to bound value for {{.Dest}} of the rest while only %d left\", len(p.rest)){{else}}nil{{end}};{{end}}\n}\nif pos = bytes.IndexByte(p.rest[:{{.Upper}}], {{ .Char }}); pos >= 0 {\n  tmp = p.rest[:pos]\n  p.rest = p.rest[pos+1:]\n} else {\n  tmp = p.rest\n  p.rest = p.rest[len(p.rest):]\n}\n{{ call .Decoder \"tmp\"  .Dest }}\n",
"take_before_limited_string": "\n// Put data before {{ .ConstValue }} into {{ .Dest }} with limited to {{.Upper}} symbols boundary lookup\nif len(p.rest) < {{.Upper}} {\n{{if .Namespace}}p.{{.Namespace}}.Valid = false; goto {{.ScopeLabel}}{{else}}return false, {{ if.Serious }}fmt.Errorf(\"Requested lookup in first {{.Upper}} symbols to bound value for {{.Dest}} of the rest while only %d left\", len(p.rest)){{else}}nil{{end}};{{end}}\n}\nif pos = bytes.Index(p.rest[:{{.Upper}}], {{ .ConstName }}); pos >= 0 {\n  {{ if .UseTmp }}tmp = p.rest[:pos]\n  {{ call .Decoder \"tmp\"  .Dest }}{{else}}{{ call .Decoder \"p.rest[:pos]\"  .Dest }}{{end}}\n  p.rest = p.rest[pos+len({{.ConstName}}):]\n} else {\n{{if .Namespace}}p.{{.Namespace}}.Valid = false; goto {{.ScopeLabel}}{{else}}return false, {{ if .Serious }}fmt.Errorf(\"Cannot find `\\033[1m%s\\033[0m` in `\\033[1m%s\\033[0m` to bound data for field {{.Dest}}\", {{.ConstName}}, string(p.rest[:{{.Upper}}])){{else}}nil{{end}};{{end}}\n}",
"take_before_limited_string_or_rest": "\n// Put data before {{ .ConstValue }} into {{ .Dest }} with limited to {{.Upper}} symbols boundary lookup or everything to the very rest if not found\nif len(p.rest) < {{.Upper}} {\n{{if .Namespace}}p.{{.Namespace}}.Valid = false; goto {{.ScopeLabel}}{{else}}return false, {{ if.Serious }}fmt.Errorf(\"Requested lookup in first {{.Upper}} symbols to bound value for {{.Dest}} of the rest while only %d left\", len(p.rest)){{else}}nil{{end}};{{end}}\n}\nif pos = bytes.Index(p.rest[:{{.Upper}}], {{ .ConstName }}); pos >= 0 {\n  tmp = p.rest[:pos]\n  p.rest = p.rest[pos+len({{.ConstName}}):]\n} else {\n  tmp = p.rest\n  p.rest = p.rest[len(p.rest):]\n}\n{{ call .Decoder \"tmp\"  .Dest }}\n",
"take_before_string": "\n// Put data before {{ .ConstValue }} into {{ .Dest }}\nif pos = bytes.Index(p.rest, {{ .ConstName }}); pos >= 0 {\n  {{ if .UseTmp }}tmp = p.rest[:pos]\n  {{ call .Decoder \"tmp\"  .Dest }}{{else}}{{ call .Decoder \"p.rest[:pos]\"  .Dest }}{{end}}\n  p.rest = p.rest[pos+len({{.ConstName}}):]\n} else {\n{{if .Namespace}}p.{{.Namespace}}.Valid = false; goto {{.ScopeLabel}}{{else}}return false, {{ if .Serious }}fmt.Errorf(\"Cannot find `\\033[1m%s\\033[0m` in `\\033[1m%s\\033[0m` to bound data for field {{.Dest}}\", {{.ConstName}}, string(p.rest)){{else}}nil{{end}};{{end}}\n}",
"take_before_string_or_rest": "\n// Put data before {{ .ConstValue }} into {{ .Dest }} if found otherwise take to the end\nif pos = bytes.Index(p.rest, {{ .ConstName }}); pos >= 0 {\n  tmp = p.rest[:pos]\n  p.rest = p.rest[pos+len({{.ConstName}}):]\n} else {\n  tmp = p.rest\n  p.rest = p.rest[len(p.rest):]\n}\n{{ call .Decoder \"tmp\"  .Dest }}\n",
"take_rest": "\n// Put the rest of the data into {{.Dest}}\n{{ call .Decoder \"p.rest\" .Dest }}\np.rest = p.rest[len(p.rest):]",

}

