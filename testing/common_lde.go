
/*
 This file was autogenerated via
 ------------------------------------------------------------
 ldetool generate --package ldetesting --go-string common.lde
 ------------------------------------------------------------
 do not touch it with bare hands!
*/

package ldetesting

import (
	"fmt"
	"strconv"
	"strings"
)

var abc = "abc"

// Rule ...
type Rule struct {
	Rest     string
	Data     string
	Signed   int
	Unsigned uint
	Str      string
}

// Extract ...
func (p *Rule) Extract(line string) (bool, error) {
	p.Rest = line
	var err error
	var pos int
	var tmp string
	var tmpInt int64
	var tmpUint uint64

	// Checks if the rest starts with '[' and pass it
	if len(p.Rest) >= 1 && p.Rest[0] == '[' {
		p.Rest = p.Rest[1:]
	} else {
		return false, nil
	}

	// Take until ']' as Data(string)
	pos = strings.IndexByte(p.Rest, ']')
	if pos >= 0 {
		p.Data = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, nil
	}

	// Checks if the rest starts with ' ' and pass it
	if len(p.Rest) >= 1 && p.Rest[0] == ' ' {
		p.Rest = p.Rest[1:]
	} else {
		return false, nil
	}

	// Take until ' ' as Signed(int)
	pos = strings.IndexByte(p.Rest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpInt, err = strconv.ParseInt(tmp, 10, 64); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Signed(int): %s", tmp, err)
	}
	p.Signed = int(tmpInt)

	// Checks if the rest starts with ' ' and pass it
	if len(p.Rest) >= 1 && p.Rest[0] == ' ' {
		p.Rest = p.Rest[1:]
	} else {
		return false, nil
	}

	// Take until ' ' as Unsigned(uint)
	pos = strings.IndexByte(p.Rest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpUint, err = strconv.ParseUint(tmp, 10, 64); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Unsigned(uint): %s", tmp, err)
	}
	p.Unsigned = uint(tmpUint)

	// Take the rest as Str(str)
	p.Str = p.Rest
	p.Rest = p.Rest[len(p.Rest):]
	return true, nil
}

// BeforeLookup ...
type BeforeLookup struct {
	Rest string
	Data string
}

// Extract ...
func (p *BeforeLookup) Extract(line string) (bool, error) {
	p.Rest = line
	var pos int

	// Looking for "abc" and then pass it
	pos = strings.Index(p.Rest, abc)
	if pos >= 0 {
		p.Rest = p.Rest[pos:]
	} else {
		return false, nil
	}

	// Take the rest as Data(string)
	p.Data = p.Rest
	p.Rest = p.Rest[len(p.Rest):]
	return true, nil
}

// CheckPrefix ...
type CheckPrefix struct {
	Rest string
	Data string
}

// Extract ...
func (p *CheckPrefix) Extract(line string) (bool, error) {
	p.Rest = line

	// Checks if the rest starts with `"abc"`
	if !strings.HasPrefix(p.Rest, abc) {
		return false, nil
	}

	// Take the rest as Data(string)
	p.Data = p.Rest
	p.Rest = p.Rest[len(p.Rest):]
	return true, nil
}

// PassHeadingStringRegression ...
type PassHeadingStringRegression struct {
	Rest string
	Data string
}

// Extract ...
func (p *PassHeadingStringRegression) Extract(line string) (bool, error) {
	p.Rest = line
	var headPassCounter int
	var headPassValue rune

	// Pass all characters '#' at the rest start
	for headPassCounter, headPassValue = range string(p.Rest) {
		if headPassValue != '#' {
			break
		}
	}
	if headPassCounter > 0 {
		p.Rest = p.Rest[headPassCounter:]
	}

	// Take the rest as Data(string)
	p.Data = p.Rest
	p.Rest = p.Rest[len(p.Rest):]
	return true, nil
}
