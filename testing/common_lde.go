
/*
 This file was autogenerated via
 ------------------------------------------------------------
 ldetool generate --package ldetesting --go-string common.lde
 ------------------------------------------------------------
 do not touch it with bare hands!
*/

package ldetesting

import (
	"fmt"
	"strconv"
	"strings"
)

// Rule ...
type Rule struct {
	Rest     string
	Data     string
	Signed   int
	Unsigned uint
	Str      string
}

// Extract ...
func (p *Rule) Extract(line string) (bool, error) {
	p.Rest = line
	var err error
	var pos int
	var tmp string
	var tmpInt int64
	var tmpUint uint64

	// Checks if the rest starts with '[' and pass it
	if len(p.Rest) >= 1 && p.Rest[0] == '[' {
		p.Rest = p.Rest[1:]
	} else {
		return false, nil
	}

	// Take until ']' as Data(string)
	pos = strings.IndexByte(p.Rest, ']')
	if pos >= 0 {
		p.Data = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, nil
	}

	// Checks if the rest starts with ' ' and pass it
	if len(p.Rest) >= 1 && p.Rest[0] == ' ' {
		p.Rest = p.Rest[1:]
	} else {
		return false, nil
	}

	// Take until ' ' as Signed(int)
	pos = strings.IndexByte(p.Rest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpInt, err = strconv.ParseInt(tmp, 10, 64); err != nil {
		return false, fmt.Errorf("Cannot parse `%s` into Signed(int): %s", tmp, err)
	}
	p.Signed = int(tmpInt)

	// Checks if the rest starts with ' ' and pass it
	if len(p.Rest) >= 1 && p.Rest[0] == ' ' {
		p.Rest = p.Rest[1:]
	} else {
		return false, nil
	}

	// Take until ' ' as Unsigned(uint)
	pos = strings.IndexByte(p.Rest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpUint, err = strconv.ParseUint(tmp, 10, 64); err != nil {
		return false, fmt.Errorf("Cannot parse `%s` into Unsigned(uint): %s", tmp, err)
	}
	p.Unsigned = uint(tmpUint)

	// Take the rest as Str(str)
	p.Str = p.Rest
	p.Rest = p.Rest[len(p.Rest):]
	return true, nil
}
