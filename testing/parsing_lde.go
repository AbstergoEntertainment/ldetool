/*
 This file was autogenerated via
 -----------------------------------------------------------------------------
 ldetool generate --little-endian --package ldetesting --go-string parsing.lde
 -----------------------------------------------------------------------------
 do not touch it with bare hands!
*/

package ldetesting

import (
	"fmt"
	"strconv"
	"strings"
)

var ataEq = "ata="
var ba = "ba"
var const1234 = "1234"
var const12345 = "12345"
var const123456789 = "123456789"
var const34 = "34"
var dogs = "@@"
var end = "end"
var headEq = "head="
var restEq = "rest="
var space = " "
var startSpace = "start "

// Decoders ...
type Decoders struct {
	rest    string
	Int8    int8
	Int16   int16
	Int32   int32
	Int64   int64
	Uint8   uint8
	Uint16  uint16
	Uint32  uint32
	Uint64  uint64
	Float32 float32
	Float64 float64
	String  string
}

// Extract ...
func (p *Decoders) Extract(line string) (bool, error) {
	p.rest = line
	var err error
	var pos int
	var tmp string
	var tmpFloat float64
	var tmpInt int64
	var tmpUint uint64

	// Take until ' ' as Int8(int8)
	pos = strings.IndexByte(p.rest, ' ')
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpInt, err = strconv.ParseInt(tmp, 10, 8); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Int8 = int8(tmpInt)

	// Take until ' ' as Int16(int16)
	pos = strings.IndexByte(p.rest, ' ')
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpInt, err = strconv.ParseInt(tmp, 10, 16); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Int16 = int16(tmpInt)

	// Take until ' ' as Int32(int32)
	pos = strings.IndexByte(p.rest, ' ')
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpInt, err = strconv.ParseInt(tmp, 10, 32); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Int32 = int32(tmpInt)

	// Take until ' ' as Int64(int64)
	pos = strings.IndexByte(p.rest, ' ')
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpInt, err = strconv.ParseInt(tmp, 10, 64); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Int64 = int64(tmpInt)

	// Take until ' ' as Uint8(uint8)
	pos = strings.IndexByte(p.rest, ' ')
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpUint, err = strconv.ParseUint(tmp, 10, 8); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Uint8 = uint8(tmpUint)

	// Take until ' ' as Uint16(uint16)
	pos = strings.IndexByte(p.rest, ' ')
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpUint, err = strconv.ParseUint(tmp, 10, 16); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Uint16 = uint16(tmpUint)

	// Take until ' ' as Uint32(uint32)
	pos = strings.IndexByte(p.rest, ' ')
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpUint, err = strconv.ParseUint(tmp, 10, 32); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Uint32 = uint32(tmpUint)

	// Take until ' ' as Uint64(uint64)
	pos = strings.IndexByte(p.rest, ' ')
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpUint, err = strconv.ParseUint(tmp, 10, 64); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Uint64 = uint64(tmpUint)

	// Take until ' ' as Float32(float32)
	pos = strings.IndexByte(p.rest, ' ')
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpFloat, err = strconv.ParseFloat(tmp, 32); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Float32 = float32(tmpFloat)

	// Take until ' ' as Float64(float64)
	pos = strings.IndexByte(p.rest, ' ')
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpFloat, err = strconv.ParseFloat(tmp, 64); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Float64 = float64(tmpFloat)

	// Take until ' ' as String(string)
	pos = strings.IndexByte(p.rest, ' ')
	if pos >= 0 {
		p.String = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}

	return true, nil
}

// DecodersLimited ...
type DecodersLimited struct {
	rest    string
	Int8    int8
	Int16   int16
	Int32   int32
	Int64   int64
	Uint8   uint8
	Uint16  uint16
	Uint32  uint32
	Uint64  uint64
	Float32 float32
	Float64 float64
	String  string
}

// Extract ...
func (p *DecodersLimited) Extract(line string) (bool, error) {
	p.rest = line
	var err error
	var pos int
	var tmp string
	var tmpFloat float64
	var tmpInt int64
	var tmpUint uint64

	// Take until ' ' as Int8(int8)
	if len(p.rest) < 8 {
		return false, fmt.Errorf("Cannot slice up to %d as only %d characters left in the rest (`\033[1m%s\033[0m`)", 8, len(p.rest), string(p.rest))
	}
	pos = strings.IndexByte(p.rest[:8], ' ')
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Int8", ' ', string(p.rest[:8]))
	}
	if tmpInt, err = strconv.ParseInt(tmp, 10, 8); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Int8 = int8(tmpInt)

	// Take until ' ' as Int16(int16)
	if len(p.rest) < 8 {
		return false, fmt.Errorf("Cannot slice up to %d as only %d characters left in the rest (`\033[1m%s\033[0m`)", 8, len(p.rest), string(p.rest))
	}
	pos = strings.IndexByte(p.rest[:8], ' ')
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Int16", ' ', string(p.rest[:8]))
	}
	if tmpInt, err = strconv.ParseInt(tmp, 10, 16); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Int16 = int16(tmpInt)

	// Take until ' ' as Int32(int32)
	if len(p.rest) < 8 {
		return false, fmt.Errorf("Cannot slice up to %d as only %d characters left in the rest (`\033[1m%s\033[0m`)", 8, len(p.rest), string(p.rest))
	}
	pos = strings.IndexByte(p.rest[:8], ' ')
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Int32", ' ', string(p.rest[:8]))
	}
	if tmpInt, err = strconv.ParseInt(tmp, 10, 32); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Int32 = int32(tmpInt)

	// Take until ' ' as Int64(int64)
	if len(p.rest) < 8 {
		return false, fmt.Errorf("Cannot slice up to %d as only %d characters left in the rest (`\033[1m%s\033[0m`)", 8, len(p.rest), string(p.rest))
	}
	pos = strings.IndexByte(p.rest[:8], ' ')
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Int64", ' ', string(p.rest[:8]))
	}
	if tmpInt, err = strconv.ParseInt(tmp, 10, 64); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Int64 = int64(tmpInt)

	// Take until ' ' as Uint8(uint8)
	if len(p.rest) < 8 {
		return false, fmt.Errorf("Cannot slice up to %d as only %d characters left in the rest (`\033[1m%s\033[0m`)", 8, len(p.rest), string(p.rest))
	}
	pos = strings.IndexByte(p.rest[:8], ' ')
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint8", ' ', string(p.rest[:8]))
	}
	if tmpUint, err = strconv.ParseUint(tmp, 10, 8); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Uint8 = uint8(tmpUint)

	// Take until ' ' as Uint16(uint16)
	if len(p.rest) < 8 {
		return false, fmt.Errorf("Cannot slice up to %d as only %d characters left in the rest (`\033[1m%s\033[0m`)", 8, len(p.rest), string(p.rest))
	}
	pos = strings.IndexByte(p.rest[:8], ' ')
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint16", ' ', string(p.rest[:8]))
	}
	if tmpUint, err = strconv.ParseUint(tmp, 10, 16); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Uint16 = uint16(tmpUint)

	// Take until ' ' as Uint32(uint32)
	if len(p.rest) < 8 {
		return false, fmt.Errorf("Cannot slice up to %d as only %d characters left in the rest (`\033[1m%s\033[0m`)", 8, len(p.rest), string(p.rest))
	}
	pos = strings.IndexByte(p.rest[:8], ' ')
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint32", ' ', string(p.rest[:8]))
	}
	if tmpUint, err = strconv.ParseUint(tmp, 10, 32); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Uint32 = uint32(tmpUint)

	// Take until ' ' as Uint64(uint64)
	if len(p.rest) < 8 {
		return false, fmt.Errorf("Cannot slice up to %d as only %d characters left in the rest (`\033[1m%s\033[0m`)", 8, len(p.rest), string(p.rest))
	}
	pos = strings.IndexByte(p.rest[:8], ' ')
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint64", ' ', string(p.rest[:8]))
	}
	if tmpUint, err = strconv.ParseUint(tmp, 10, 64); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Uint64 = uint64(tmpUint)

	// Take until ' ' as Float32(float32)
	if len(p.rest) < 8 {
		return false, fmt.Errorf("Cannot slice up to %d as only %d characters left in the rest (`\033[1m%s\033[0m`)", 8, len(p.rest), string(p.rest))
	}
	pos = strings.IndexByte(p.rest[:8], ' ')
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Float32", ' ', string(p.rest[:8]))
	}
	if tmpFloat, err = strconv.ParseFloat(tmp, 32); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Float32 = float32(tmpFloat)

	// Take until ' ' as Float64(float64)
	if len(p.rest) < 8 {
		return false, fmt.Errorf("Cannot slice up to %d as only %d characters left in the rest (`\033[1m%s\033[0m`)", 8, len(p.rest), string(p.rest))
	}
	pos = strings.IndexByte(p.rest[:8], ' ')
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Float64", ' ', string(p.rest[:8]))
	}
	if tmpFloat, err = strconv.ParseFloat(tmp, 64); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Float64 = float64(tmpFloat)

	// Take until ' ' as String(string)
	if len(p.rest) < 8 {
		return false, fmt.Errorf("Cannot slice up to %d as only %d characters left in the rest (`\033[1m%s\033[0m`)", 8, len(p.rest), string(p.rest))
	}
	pos = strings.IndexByte(p.rest[:8], ' ')
	if pos >= 0 {
		p.String = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field String", ' ', string(p.rest[:8]))
	}

	return true, nil
}

// DecodersBounded ...
type DecodersBounded struct {
	rest  string
	Int64 int64
}

// Extract ...
func (p *DecodersBounded) Extract(line string) (bool, error) {
	p.rest = line
	var err error
	var pos int
	var tmp string
	var tmpInt int64

	// Take until ' ' as Int64(int64)
	if len(p.rest) < 16 {
		return false, nil
	}
	pos = strings.IndexByte(p.rest[8:16], ' ')
	if pos >= 0 {
		tmp = p.rest[:pos+8]
		p.rest = p.rest[pos+1+8:]
	} else {
		return false, nil
	}
	if tmpInt, err = strconv.ParseInt(tmp, 10, 64); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Int64 = int64(tmpInt)

	return true, nil
}

// DecodersString ...
type DecodersString struct {
	rest    string
	Int8    int8
	Int16   int16
	Int32   int32
	Int64   int64
	Uint8   uint8
	Uint16  uint16
	Uint32  uint32
	Uint64  uint64
	Float32 float32
	Float64 float64
	String  string
}

// Extract ...
func (p *DecodersString) Extract(line string) (bool, error) {
	p.rest = line
	var err error
	var pos int
	var tmp string
	var tmpFloat float64
	var tmpInt int64
	var tmpUint uint64

	// Take until " " as Int8(int8)
	pos = strings.Index(p.rest, space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}
	if tmpInt, err = strconv.ParseInt(tmp, 10, 8); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Int8 = int8(tmpInt)

	// Take until " " as Int16(int16)
	pos = strings.Index(p.rest, space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}
	if tmpInt, err = strconv.ParseInt(tmp, 10, 16); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Int16 = int16(tmpInt)

	// Take until " " as Int32(int32)
	pos = strings.Index(p.rest, space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}
	if tmpInt, err = strconv.ParseInt(tmp, 10, 32); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Int32 = int32(tmpInt)

	// Take until " " as Int64(int64)
	pos = strings.Index(p.rest, space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}
	if tmpInt, err = strconv.ParseInt(tmp, 10, 64); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Int64 = int64(tmpInt)

	// Take until " " as Uint8(uint8)
	pos = strings.Index(p.rest, space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}
	if tmpUint, err = strconv.ParseUint(tmp, 10, 8); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Uint8 = uint8(tmpUint)

	// Take until " " as Uint16(uint16)
	pos = strings.Index(p.rest, space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}
	if tmpUint, err = strconv.ParseUint(tmp, 10, 16); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Uint16 = uint16(tmpUint)

	// Take until " " as Uint32(uint32)
	pos = strings.Index(p.rest, space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}
	if tmpUint, err = strconv.ParseUint(tmp, 10, 32); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Uint32 = uint32(tmpUint)

	// Take until " " as Uint64(uint64)
	pos = strings.Index(p.rest, space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}
	if tmpUint, err = strconv.ParseUint(tmp, 10, 64); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Uint64 = uint64(tmpUint)

	// Take until " " as Float32(float32)
	pos = strings.Index(p.rest, space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}
	if tmpFloat, err = strconv.ParseFloat(tmp, 32); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Float32 = float32(tmpFloat)

	// Take until " " as Float64(float64)
	pos = strings.Index(p.rest, space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}
	if tmpFloat, err = strconv.ParseFloat(tmp, 64); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Float64 = float64(tmpFloat)

	// Take until " " as String(string)
	pos = strings.Index(p.rest, space)
	if pos >= 0 {
		p.String = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}

	return true, nil
}

// DecodersLimitedString ...
type DecodersLimitedString struct {
	rest    string
	Int8    int8
	Int16   int16
	Int32   int32
	Int64   int64
	Uint8   uint8
	Uint16  uint16
	Uint32  uint32
	Uint64  uint64
	Float32 float32
	Float64 float64
	String  string
}

// Extract ...
func (p *DecodersLimitedString) Extract(line string) (bool, error) {
	p.rest = line
	var err error
	var pos int
	var tmp string
	var tmpFloat float64
	var tmpInt int64
	var tmpUint uint64

	// Take until " " as Int8(int8)
	if len(p.rest) < 8 {
		return false, nil
	}
	pos = strings.Index(p.rest[:8], space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}
	if tmpInt, err = strconv.ParseInt(tmp, 10, 8); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Int8 = int8(tmpInt)

	// Take until " " as Int16(int16)
	if len(p.rest) < 8 {
		return false, nil
	}
	pos = strings.Index(p.rest[:8], space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}
	if tmpInt, err = strconv.ParseInt(tmp, 10, 16); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Int16 = int16(tmpInt)

	// Take until " " as Int32(int32)
	if len(p.rest) < 8 {
		return false, nil
	}
	pos = strings.Index(p.rest[:8], space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}
	if tmpInt, err = strconv.ParseInt(tmp, 10, 32); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Int32 = int32(tmpInt)

	// Take until " " as Int64(int64)
	if len(p.rest) < 8 {
		return false, nil
	}
	pos = strings.Index(p.rest[:8], space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}
	if tmpInt, err = strconv.ParseInt(tmp, 10, 64); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Int64 = int64(tmpInt)

	// Take until " " as Uint8(uint8)
	if len(p.rest) < 8 {
		return false, nil
	}
	pos = strings.Index(p.rest[:8], space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}
	if tmpUint, err = strconv.ParseUint(tmp, 10, 8); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Uint8 = uint8(tmpUint)

	// Take until " " as Uint16(uint16)
	if len(p.rest) < 8 {
		return false, nil
	}
	pos = strings.Index(p.rest[:8], space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}
	if tmpUint, err = strconv.ParseUint(tmp, 10, 16); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Uint16 = uint16(tmpUint)

	// Take until " " as Uint32(uint32)
	if len(p.rest) < 8 {
		return false, nil
	}
	pos = strings.Index(p.rest[:8], space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}
	if tmpUint, err = strconv.ParseUint(tmp, 10, 32); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Uint32 = uint32(tmpUint)

	// Take until " " as Uint64(uint64)
	if len(p.rest) < 8 {
		return false, nil
	}
	pos = strings.Index(p.rest[:8], space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}
	if tmpUint, err = strconv.ParseUint(tmp, 10, 64); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Uint64 = uint64(tmpUint)

	// Take until " " as Float32(float32)
	if len(p.rest) < 8 {
		return false, nil
	}
	pos = strings.Index(p.rest[:8], space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}
	if tmpFloat, err = strconv.ParseFloat(tmp, 32); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Float32 = float32(tmpFloat)

	// Take until " " as Float64(float64)
	if len(p.rest) < 8 {
		return false, nil
	}
	pos = strings.Index(p.rest[:8], space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}
	if tmpFloat, err = strconv.ParseFloat(tmp, 64); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Float64 = float64(tmpFloat)

	// Take until " " as String(string)
	if len(p.rest) < 8 {
		return false, nil
	}
	pos = strings.Index(p.rest[:8], space)
	if pos >= 0 {
		p.String = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}

	return true, nil
}

// DecodersBoundedString ...
type DecodersBoundedString struct {
	rest    string
	Float64 float64
}

// Extract ...
func (p *DecodersBoundedString) Extract(line string) (bool, error) {
	p.rest = line
	var err error
	var pos int
	var tmp string
	var tmpFloat float64

	// Take until " " as Float64(float64)
	if len(p.rest) < 16 {
		return false, nil
	}
	pos = strings.Index(p.rest[8:16], space)
	if pos >= 0 {
		tmp = p.rest[:pos+8]
		p.rest = p.rest[pos+len(space)+8:]
	} else {
		return false, nil
	}
	if tmpFloat, err = strconv.ParseFloat(tmp, 64); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Float64 = float64(tmpFloat)

	return true, nil
}

// DecodersStress ...
type DecodersStress struct {
	rest    string
	Int8    int8
	Int16   int16
	Int32   int32
	Int64   int64
	Uint8   uint8
	Uint16  uint16
	Uint32  uint32
	Uint64  uint64
	Float32 float32
	Float64 float64
	String  string
}

// Extract ...
func (p *DecodersStress) Extract(line string) (bool, error) {
	p.rest = line
	var err error
	var pos int
	var tmp string
	var tmpFloat float64
	var tmpInt int64
	var tmpUint uint64

	// Take until ' ' as Int8(int8)
	pos = strings.IndexByte(p.rest, ' ')
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Int8", ' ', string(p.rest))
	}
	if tmpInt, err = strconv.ParseInt(tmp, 10, 8); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Int8 = int8(tmpInt)

	// Take until ' ' as Int16(int16)
	pos = strings.IndexByte(p.rest, ' ')
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Int16", ' ', string(p.rest))
	}
	if tmpInt, err = strconv.ParseInt(tmp, 10, 16); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Int16 = int16(tmpInt)

	// Take until ' ' as Int32(int32)
	pos = strings.IndexByte(p.rest, ' ')
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Int32", ' ', string(p.rest))
	}
	if tmpInt, err = strconv.ParseInt(tmp, 10, 32); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Int32 = int32(tmpInt)

	// Take until ' ' as Int64(int64)
	pos = strings.IndexByte(p.rest, ' ')
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Int64", ' ', string(p.rest))
	}
	if tmpInt, err = strconv.ParseInt(tmp, 10, 64); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Int64 = int64(tmpInt)

	// Take until ' ' as Uint8(uint8)
	pos = strings.IndexByte(p.rest, ' ')
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint8", ' ', string(p.rest))
	}
	if tmpUint, err = strconv.ParseUint(tmp, 10, 8); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Uint8 = uint8(tmpUint)

	// Take until ' ' as Uint16(uint16)
	pos = strings.IndexByte(p.rest, ' ')
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint16", ' ', string(p.rest))
	}
	if tmpUint, err = strconv.ParseUint(tmp, 10, 16); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Uint16 = uint16(tmpUint)

	// Take until ' ' as Uint32(uint32)
	pos = strings.IndexByte(p.rest, ' ')
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint32", ' ', string(p.rest))
	}
	if tmpUint, err = strconv.ParseUint(tmp, 10, 32); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Uint32 = uint32(tmpUint)

	// Take until ' ' as Uint64(uint64)
	pos = strings.IndexByte(p.rest, ' ')
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint64", ' ', string(p.rest))
	}
	if tmpUint, err = strconv.ParseUint(tmp, 10, 64); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Uint64 = uint64(tmpUint)

	// Take until ' ' as Float32(float32)
	pos = strings.IndexByte(p.rest, ' ')
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Float32", ' ', string(p.rest))
	}
	if tmpFloat, err = strconv.ParseFloat(tmp, 32); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Float32 = float32(tmpFloat)

	// Take until ' ' as Float64(float64)
	pos = strings.IndexByte(p.rest, ' ')
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Float64", ' ', string(p.rest))
	}
	if tmpFloat, err = strconv.ParseFloat(tmp, 64); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Float64 = float64(tmpFloat)

	// Take until ' ' as String(string)
	pos = strings.IndexByte(p.rest, ' ')
	if pos >= 0 {
		p.String = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field String", ' ', string(p.rest))
	}

	return true, nil
}

// DecodersLimitedStress ...
type DecodersLimitedStress struct {
	rest    string
	Int8    int8
	Int16   int16
	Int32   int32
	Int64   int64
	Uint8   uint8
	Uint16  uint16
	Uint32  uint32
	Uint64  uint64
	Float32 float32
	Float64 float64
	String  string
}

// Extract ...
func (p *DecodersLimitedStress) Extract(line string) (bool, error) {
	p.rest = line
	var err error
	var pos int
	var tmp string
	var tmpFloat float64
	var tmpInt int64
	var tmpUint uint64

	// Take until ' ' as Int8(int8)
	if len(p.rest) < 8 {
		return false, fmt.Errorf("Cannot slice up to %d as only %d characters left in the rest (`\033[1m%s\033[0m`)", 8, len(p.rest), string(p.rest))
	}
	pos = strings.IndexByte(p.rest[:8], ' ')
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Int8", ' ', string(p.rest[:8]))
	}
	if tmpInt, err = strconv.ParseInt(tmp, 10, 8); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Int8 = int8(tmpInt)

	// Take until ' ' as Int16(int16)
	if len(p.rest) < 8 {
		return false, fmt.Errorf("Cannot slice up to %d as only %d characters left in the rest (`\033[1m%s\033[0m`)", 8, len(p.rest), string(p.rest))
	}
	pos = strings.IndexByte(p.rest[:8], ' ')
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Int16", ' ', string(p.rest[:8]))
	}
	if tmpInt, err = strconv.ParseInt(tmp, 10, 16); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Int16 = int16(tmpInt)

	// Take until ' ' as Int32(int32)
	if len(p.rest) < 8 {
		return false, fmt.Errorf("Cannot slice up to %d as only %d characters left in the rest (`\033[1m%s\033[0m`)", 8, len(p.rest), string(p.rest))
	}
	pos = strings.IndexByte(p.rest[:8], ' ')
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Int32", ' ', string(p.rest[:8]))
	}
	if tmpInt, err = strconv.ParseInt(tmp, 10, 32); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Int32 = int32(tmpInt)

	// Take until ' ' as Int64(int64)
	if len(p.rest) < 8 {
		return false, fmt.Errorf("Cannot slice up to %d as only %d characters left in the rest (`\033[1m%s\033[0m`)", 8, len(p.rest), string(p.rest))
	}
	pos = strings.IndexByte(p.rest[:8], ' ')
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Int64", ' ', string(p.rest[:8]))
	}
	if tmpInt, err = strconv.ParseInt(tmp, 10, 64); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Int64 = int64(tmpInt)

	// Take until ' ' as Uint8(uint8)
	if len(p.rest) < 8 {
		return false, fmt.Errorf("Cannot slice up to %d as only %d characters left in the rest (`\033[1m%s\033[0m`)", 8, len(p.rest), string(p.rest))
	}
	pos = strings.IndexByte(p.rest[:8], ' ')
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint8", ' ', string(p.rest[:8]))
	}
	if tmpUint, err = strconv.ParseUint(tmp, 10, 8); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Uint8 = uint8(tmpUint)

	// Take until ' ' as Uint16(uint16)
	if len(p.rest) < 8 {
		return false, fmt.Errorf("Cannot slice up to %d as only %d characters left in the rest (`\033[1m%s\033[0m`)", 8, len(p.rest), string(p.rest))
	}
	pos = strings.IndexByte(p.rest[:8], ' ')
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint16", ' ', string(p.rest[:8]))
	}
	if tmpUint, err = strconv.ParseUint(tmp, 10, 16); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Uint16 = uint16(tmpUint)

	// Take until ' ' as Uint32(uint32)
	if len(p.rest) < 8 {
		return false, fmt.Errorf("Cannot slice up to %d as only %d characters left in the rest (`\033[1m%s\033[0m`)", 8, len(p.rest), string(p.rest))
	}
	pos = strings.IndexByte(p.rest[:8], ' ')
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint32", ' ', string(p.rest[:8]))
	}
	if tmpUint, err = strconv.ParseUint(tmp, 10, 32); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Uint32 = uint32(tmpUint)

	// Take until ' ' as Uint64(uint64)
	if len(p.rest) < 8 {
		return false, fmt.Errorf("Cannot slice up to %d as only %d characters left in the rest (`\033[1m%s\033[0m`)", 8, len(p.rest), string(p.rest))
	}
	pos = strings.IndexByte(p.rest[:8], ' ')
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint64", ' ', string(p.rest[:8]))
	}
	if tmpUint, err = strconv.ParseUint(tmp, 10, 64); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Uint64 = uint64(tmpUint)

	// Take until ' ' as Float32(float32)
	if len(p.rest) < 8 {
		return false, fmt.Errorf("Cannot slice up to %d as only %d characters left in the rest (`\033[1m%s\033[0m`)", 8, len(p.rest), string(p.rest))
	}
	pos = strings.IndexByte(p.rest[:8], ' ')
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Float32", ' ', string(p.rest[:8]))
	}
	if tmpFloat, err = strconv.ParseFloat(tmp, 32); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Float32 = float32(tmpFloat)

	// Take until ' ' as Float64(float64)
	if len(p.rest) < 8 {
		return false, fmt.Errorf("Cannot slice up to %d as only %d characters left in the rest (`\033[1m%s\033[0m`)", 8, len(p.rest), string(p.rest))
	}
	pos = strings.IndexByte(p.rest[:8], ' ')
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Float64", ' ', string(p.rest[:8]))
	}
	if tmpFloat, err = strconv.ParseFloat(tmp, 64); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Float64 = float64(tmpFloat)

	// Take until ' ' as String(string)
	if len(p.rest) < 8 {
		return false, fmt.Errorf("Cannot slice up to %d as only %d characters left in the rest (`\033[1m%s\033[0m`)", 8, len(p.rest), string(p.rest))
	}
	pos = strings.IndexByte(p.rest[:8], ' ')
	if pos >= 0 {
		p.String = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field String", ' ', string(p.rest[:8]))
	}

	return true, nil
}

// DecodersBoundedStress ...
type DecodersBoundedStress struct {
	rest  string
	Int64 int64
}

// Extract ...
func (p *DecodersBoundedStress) Extract(line string) (bool, error) {
	p.rest = line
	var err error
	var pos int
	var tmp string
	var tmpInt int64

	// Take until ' ' as Int64(int64)
	if len(p.rest) < 16 {
		return false, fmt.Errorf("Cannot slice up to %d as only %d characters left in the rest (`\033[1m%s\033[0m`)", 16, len(p.rest), string(p.rest))
	}
	pos = strings.IndexByte(p.rest[8:16], ' ')
	if pos >= 0 {
		tmp = p.rest[:pos+8]
		p.rest = p.rest[pos+1+8:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Int64", ' ', string(p.rest[8:16]))
	}
	if tmpInt, err = strconv.ParseInt(tmp, 10, 64); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Int64 = int64(tmpInt)

	return true, nil
}

// DecodersStringStress ...
type DecodersStringStress struct {
	rest    string
	Int8    int8
	Int16   int16
	Int32   int32
	Int64   int64
	Uint8   uint8
	Uint16  uint16
	Uint32  uint32
	Uint64  uint64
	Float32 float32
	Float64 float64
	String  string
}

// Extract ...
func (p *DecodersStringStress) Extract(line string) (bool, error) {
	p.rest = line
	var err error
	var pos int
	var tmp string
	var tmpFloat float64
	var tmpInt int64
	var tmpUint uint64

	// Take until " " as Int8(int8)
	pos = strings.Index(p.rest, space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Int8", space, string(p.rest))
	}
	if tmpInt, err = strconv.ParseInt(tmp, 10, 8); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Int8 = int8(tmpInt)

	// Take until " " as Int16(int16)
	pos = strings.Index(p.rest, space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Int16", space, string(p.rest))
	}
	if tmpInt, err = strconv.ParseInt(tmp, 10, 16); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Int16 = int16(tmpInt)

	// Take until " " as Int32(int32)
	pos = strings.Index(p.rest, space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Int32", space, string(p.rest))
	}
	if tmpInt, err = strconv.ParseInt(tmp, 10, 32); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Int32 = int32(tmpInt)

	// Take until " " as Int64(int64)
	pos = strings.Index(p.rest, space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Int64", space, string(p.rest))
	}
	if tmpInt, err = strconv.ParseInt(tmp, 10, 64); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Int64 = int64(tmpInt)

	// Take until " " as Uint8(uint8)
	pos = strings.Index(p.rest, space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint8", space, string(p.rest))
	}
	if tmpUint, err = strconv.ParseUint(tmp, 10, 8); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Uint8 = uint8(tmpUint)

	// Take until " " as Uint16(uint16)
	pos = strings.Index(p.rest, space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint16", space, string(p.rest))
	}
	if tmpUint, err = strconv.ParseUint(tmp, 10, 16); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Uint16 = uint16(tmpUint)

	// Take until " " as Uint32(uint32)
	pos = strings.Index(p.rest, space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint32", space, string(p.rest))
	}
	if tmpUint, err = strconv.ParseUint(tmp, 10, 32); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Uint32 = uint32(tmpUint)

	// Take until " " as Uint64(uint64)
	pos = strings.Index(p.rest, space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint64", space, string(p.rest))
	}
	if tmpUint, err = strconv.ParseUint(tmp, 10, 64); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Uint64 = uint64(tmpUint)

	// Take until " " as Float32(float32)
	pos = strings.Index(p.rest, space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Float32", space, string(p.rest))
	}
	if tmpFloat, err = strconv.ParseFloat(tmp, 32); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Float32 = float32(tmpFloat)

	// Take until " " as Float64(float64)
	pos = strings.Index(p.rest, space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Float64", space, string(p.rest))
	}
	if tmpFloat, err = strconv.ParseFloat(tmp, 64); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Float64 = float64(tmpFloat)

	// Take until " " as String(string)
	pos = strings.Index(p.rest, space)
	if pos >= 0 {
		p.String = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field String", space, string(p.rest))
	}

	return true, nil
}

// DecodersLimitedStringStress ...
type DecodersLimitedStringStress struct {
	rest    string
	Int8    int8
	Int16   int16
	Int32   int32
	Int64   int64
	Uint8   uint8
	Uint16  uint16
	Uint32  uint32
	Uint64  uint64
	Float32 float32
	Float64 float64
	String  string
}

// Extract ...
func (p *DecodersLimitedStringStress) Extract(line string) (bool, error) {
	p.rest = line
	var err error
	var pos int
	var tmp string
	var tmpFloat float64
	var tmpInt int64
	var tmpUint uint64

	// Take until " " as Int8(int8)
	if len(p.rest) < 8 {
		return false, fmt.Errorf("Cannot slice up to %d as only %d characters left in the rest (`\033[1m%s\033[0m`)", 8, len(p.rest), string(p.rest))
	}
	pos = strings.Index(p.rest[:8], space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Int8", space, string(p.rest[:8]))
	}
	if tmpInt, err = strconv.ParseInt(tmp, 10, 8); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Int8 = int8(tmpInt)

	// Take until " " as Int16(int16)
	if len(p.rest) < 8 {
		return false, fmt.Errorf("Cannot slice up to %d as only %d characters left in the rest (`\033[1m%s\033[0m`)", 8, len(p.rest), string(p.rest))
	}
	pos = strings.Index(p.rest[:8], space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Int16", space, string(p.rest[:8]))
	}
	if tmpInt, err = strconv.ParseInt(tmp, 10, 16); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Int16 = int16(tmpInt)

	// Take until " " as Int32(int32)
	if len(p.rest) < 8 {
		return false, fmt.Errorf("Cannot slice up to %d as only %d characters left in the rest (`\033[1m%s\033[0m`)", 8, len(p.rest), string(p.rest))
	}
	pos = strings.Index(p.rest[:8], space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Int32", space, string(p.rest[:8]))
	}
	if tmpInt, err = strconv.ParseInt(tmp, 10, 32); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Int32 = int32(tmpInt)

	// Take until " " as Int64(int64)
	if len(p.rest) < 8 {
		return false, fmt.Errorf("Cannot slice up to %d as only %d characters left in the rest (`\033[1m%s\033[0m`)", 8, len(p.rest), string(p.rest))
	}
	pos = strings.Index(p.rest[:8], space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Int64", space, string(p.rest[:8]))
	}
	if tmpInt, err = strconv.ParseInt(tmp, 10, 64); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Int64 = int64(tmpInt)

	// Take until " " as Uint8(uint8)
	if len(p.rest) < 8 {
		return false, fmt.Errorf("Cannot slice up to %d as only %d characters left in the rest (`\033[1m%s\033[0m`)", 8, len(p.rest), string(p.rest))
	}
	pos = strings.Index(p.rest[:8], space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint8", space, string(p.rest[:8]))
	}
	if tmpUint, err = strconv.ParseUint(tmp, 10, 8); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Uint8 = uint8(tmpUint)

	// Take until " " as Uint16(uint16)
	if len(p.rest) < 8 {
		return false, fmt.Errorf("Cannot slice up to %d as only %d characters left in the rest (`\033[1m%s\033[0m`)", 8, len(p.rest), string(p.rest))
	}
	pos = strings.Index(p.rest[:8], space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint16", space, string(p.rest[:8]))
	}
	if tmpUint, err = strconv.ParseUint(tmp, 10, 16); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Uint16 = uint16(tmpUint)

	// Take until " " as Uint32(uint32)
	if len(p.rest) < 8 {
		return false, fmt.Errorf("Cannot slice up to %d as only %d characters left in the rest (`\033[1m%s\033[0m`)", 8, len(p.rest), string(p.rest))
	}
	pos = strings.Index(p.rest[:8], space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint32", space, string(p.rest[:8]))
	}
	if tmpUint, err = strconv.ParseUint(tmp, 10, 32); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Uint32 = uint32(tmpUint)

	// Take until " " as Uint64(uint64)
	if len(p.rest) < 8 {
		return false, fmt.Errorf("Cannot slice up to %d as only %d characters left in the rest (`\033[1m%s\033[0m`)", 8, len(p.rest), string(p.rest))
	}
	pos = strings.Index(p.rest[:8], space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint64", space, string(p.rest[:8]))
	}
	if tmpUint, err = strconv.ParseUint(tmp, 10, 64); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Uint64 = uint64(tmpUint)

	// Take until " " as Float32(float32)
	if len(p.rest) < 8 {
		return false, fmt.Errorf("Cannot slice up to %d as only %d characters left in the rest (`\033[1m%s\033[0m`)", 8, len(p.rest), string(p.rest))
	}
	pos = strings.Index(p.rest[:8], space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Float32", space, string(p.rest[:8]))
	}
	if tmpFloat, err = strconv.ParseFloat(tmp, 32); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Float32 = float32(tmpFloat)

	// Take until " " as Float64(float64)
	if len(p.rest) < 8 {
		return false, fmt.Errorf("Cannot slice up to %d as only %d characters left in the rest (`\033[1m%s\033[0m`)", 8, len(p.rest), string(p.rest))
	}
	pos = strings.Index(p.rest[:8], space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Float64", space, string(p.rest[:8]))
	}
	if tmpFloat, err = strconv.ParseFloat(tmp, 64); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Float64 = float64(tmpFloat)

	// Take until " " as String(string)
	if len(p.rest) < 8 {
		return false, fmt.Errorf("Cannot slice up to %d as only %d characters left in the rest (`\033[1m%s\033[0m`)", 8, len(p.rest), string(p.rest))
	}
	pos = strings.Index(p.rest[:8], space)
	if pos >= 0 {
		p.String = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field String", space, string(p.rest[:8]))
	}

	return true, nil
}

// DecodersBoundedStringStress ...
type DecodersBoundedStringStress struct {
	rest    string
	Float64 float64
}

// Extract ...
func (p *DecodersBoundedStringStress) Extract(line string) (bool, error) {
	p.rest = line
	var err error
	var pos int
	var tmp string
	var tmpFloat float64

	// Take until " " as Float64(float64)
	if len(p.rest) < 16 {
		return false, fmt.Errorf("Cannot slice up to %d as only %d characters left in the rest (`\033[1m%s\033[0m`)", 16, len(p.rest), string(p.rest))
	}
	pos = strings.Index(p.rest[8:16], space)
	if pos >= 0 {
		tmp = p.rest[:pos+8]
		p.rest = p.rest[pos+len(space)+8:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Float64", space, string(p.rest[8:16]))
	}
	if tmpFloat, err = strconv.ParseFloat(tmp, 64); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Float64 = float64(tmpFloat)

	return true, nil
}

// DecoderOptionals ...
type DecoderOptionals struct {
	rest string
	Int8 int8
	Head struct {
		Valid bool
		Data  string
	}
}

// Extract ...
func (p *DecoderOptionals) Extract(line string) (bool, error) {
	p.rest = line
	var err error
	var pos int
	var rest1 string
	var tmp string
	var tmpInt int64

	// Take until ' ' as Int8(int8)
	pos = strings.IndexByte(p.rest, ' ')
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpInt, err = strconv.ParseInt(tmp, 10, 8); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Int8 = int8(tmpInt)
	rest1 = p.rest

	// Checks if the rest starts with `"head="` and pass it
	if strings.HasPrefix(rest1, headEq) {
		rest1 = rest1[len(headEq):]
	} else {
		p.Head.Valid = false
		goto decoderoptionalsHeadLabel
	}

	// Take until ' ' as Data(string)
	pos = strings.IndexByte(rest1, ' ')
	if pos >= 0 {
		p.Head.Data = rest1[:pos]
		rest1 = rest1[pos+1:]
	} else {
		p.Head.Valid = false
		goto decoderoptionalsHeadLabel
	}
	p.Head.Valid = true
	p.rest = rest1
decoderoptionalsHeadLabel:

	// Checks if the rest starts with `"end"` and pass it
	if strings.HasPrefix(p.rest, end) {
		p.rest = p.rest[len(end):]
	} else {
		return false, nil
	}

	return true, nil
}

// GetHeadData ...
func (p *DecoderOptionals) GetHeadData() (res string) {
	if p.Head.Valid {
		res = p.Head.Data
	}
	return
}

// DecoderOptionalsStress ...
type DecoderOptionalsStress struct {
	rest string
	Int8 int8
	Head struct {
		Valid bool
		Data  string
	}
}

// Extract ...
func (p *DecoderOptionalsStress) Extract(line string) (bool, error) {
	p.rest = line
	var err error
	var pos int
	var rest1 string
	var tmp string
	var tmpInt int64

	// Take until ' ' as Int8(int8)
	pos = strings.IndexByte(p.rest, ' ')
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Int8", ' ', string(p.rest))
	}
	if tmpInt, err = strconv.ParseInt(tmp, 10, 8); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Int8 = int8(tmpInt)
	rest1 = p.rest

	// Checks if the rest starts with `"head="` and pass it
	if strings.HasPrefix(rest1, headEq) {
		rest1 = rest1[len(headEq):]
	} else {
		p.Head.Valid = false
		goto decoderoptionalsstressHeadLabel
	}

	// Take until ' ' as Data(string)
	pos = strings.IndexByte(rest1, ' ')
	if pos >= 0 {
		p.Head.Data = rest1[:pos]
		rest1 = rest1[pos+1:]
	} else {
		p.Head.Valid = false
		goto decoderoptionalsstressHeadLabel
	}
	p.Head.Valid = true
	p.rest = rest1
decoderoptionalsstressHeadLabel:

	// Checks if the rest starts with `"end"` and pass it
	if strings.HasPrefix(p.rest, end) {
		p.rest = p.rest[len(end):]
	} else {
		return false, fmt.Errorf("`\033[1m%s\033[0m` is expected to start with `\033[1m%s\033[0m`", string(p.rest), "end")
	}

	return true, nil
}

// GetHeadData ...
func (p *DecoderOptionalsStress) GetHeadData() (res string) {
	if p.Head.Valid {
		res = p.Head.Data
	}
	return
}

// DecoderBranching ...
type DecoderBranching struct {
	rest string
	Head struct {
		Valid bool
		Data  string
	}
}

// Extract ...
func (p *DecoderBranching) Extract(line string) (bool, error) {
	p.rest = line
	var pos int
	var rest1 string

	// Checks if the rest starts with `"start "` and pass it
	if strings.HasPrefix(p.rest, startSpace) {
		p.rest = p.rest[len(startSpace):]
	}
	rest1 = p.rest

	// Checks if the rest starts with `"head="` and pass it
	if strings.HasPrefix(rest1, headEq) {
		rest1 = rest1[len(headEq):]
	}

	// Take until ' ' (or all the rest if not found) as Data(string)
	pos = strings.IndexByte(rest1, ' ')
	if pos >= 0 {
		p.Head.Data = rest1[:pos]
		rest1 = rest1[pos+1:]
	} else {
		p.Head.Data = rest1
		rest1 = rest1[len(rest1):]
	}
	p.Head.Valid = true
	p.rest = rest1

	return true, nil
}

// GetHeadData ...
func (p *DecoderBranching) GetHeadData() (res string) {
	if p.Head.Valid {
		res = p.Head.Data
	}
	return
}

// DecoderBranchingStress ...
type DecoderBranchingStress struct {
	rest string
	Head struct {
		Valid bool
		Data  string
	}
}

// Extract ...
func (p *DecoderBranchingStress) Extract(line string) (bool, error) {
	p.rest = line
	var pos int
	var rest1 string

	// Checks if the rest starts with `"start "` and pass it
	if strings.HasPrefix(p.rest, startSpace) {
		p.rest = p.rest[len(startSpace):]
	}
	rest1 = p.rest

	// Checks if the rest starts with `"head="` and pass it
	if strings.HasPrefix(rest1, headEq) {
		rest1 = rest1[len(headEq):]
	}

	// Take until ' ' (or all the rest if not found) as Data(string)
	pos = strings.IndexByte(rest1, ' ')
	if pos >= 0 {
		p.Head.Data = rest1[:pos]
		rest1 = rest1[pos+1:]
	} else {
		p.Head.Data = rest1
		rest1 = rest1[len(rest1):]
	}
	p.Head.Valid = true
	p.rest = rest1

	return true, nil
}

// GetHeadData ...
func (p *DecoderBranchingStress) GetHeadData() (res string) {
	if p.Head.Valid {
		res = p.Head.Data
	}
	return
}

// DoubleOpts ...
type DoubleOpts struct {
	rest string
	Head struct {
		Valid bool
		Data  string
	}
	Rest struct {
		Valid bool
		Data  string
	}
}

// Extract ...
func (p *DoubleOpts) Extract(line string) (bool, error) {
	p.rest = line
	var pos int
	var rest1 string
	rest1 = p.rest

	// Checks if the rest starts with `"head="` and pass it
	if strings.HasPrefix(rest1, headEq) {
		rest1 = rest1[len(headEq):]
	} else {
		p.Head.Valid = false
		goto doubleoptsHeadLabel
	}

	// Take until ' ' (or all the rest if not found) as Data(string)
	pos = strings.IndexByte(rest1, ' ')
	if pos >= 0 {
		p.Head.Data = rest1[:pos]
		rest1 = rest1[pos+1:]
	} else {
		p.Head.Data = rest1
		rest1 = rest1[len(rest1):]
	}
	p.Head.Valid = true
	p.rest = rest1
doubleoptsHeadLabel:
	rest1 = p.rest

	// Checks if the rest starts with `"rest="` and pass it
	if strings.HasPrefix(rest1, restEq) {
		rest1 = rest1[len(restEq):]
	} else {
		p.Rest.Valid = false
		goto doubleoptsRestLabel
	}

	// Take until ' ' (or all the rest if not found) as Data(string)
	pos = strings.IndexByte(rest1, ' ')
	if pos >= 0 {
		p.Rest.Data = rest1[:pos]
		rest1 = rest1[pos+1:]
	} else {
		p.Rest.Data = rest1
		rest1 = rest1[len(rest1):]
	}
	p.Rest.Valid = true
	p.rest = rest1
doubleoptsRestLabel:

	return true, nil
}

// GetHeadData ...
func (p *DoubleOpts) GetHeadData() (res string) {
	if p.Head.Valid {
		res = p.Head.Data
	}
	return
}

// GetRestData ...
func (p *DoubleOpts) GetRestData() (res string) {
	if p.Rest.Valid {
		res = p.Rest.Data
	}
	return
}

// Prefixes ...
type Prefixes struct {
	rest string
	Data int32
	Rest int32
}

// Extract ...
func (p *Prefixes) Extract(line string) (bool, error) {
	p.rest = line
	var err error
	var pos int
	var tmp string
	var tmpInt int64

	// Checks if the rest starts with `"123456789"` and pass it
	if strings.HasPrefix(p.rest, const123456789) {
		p.rest = p.rest[len(const123456789):]
	} else {
		return false, fmt.Errorf("`\033[1m%s\033[0m` is expected to start with `\033[1m%s\033[0m`", string(p.rest), "123456789")
	}

	// Take until ' ' as Data(int32)
	pos = strings.IndexByte(p.rest, ' ')
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Data", ' ', string(p.rest))
	}
	if tmpInt, err = strconv.ParseInt(tmp, 10, 32); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Data = int32(tmpInt)

	// Checks if the rest starts with `"12345"` and pass it
	if strings.HasPrefix(p.rest, const12345) {
		p.rest = p.rest[len(const12345):]
	} else {
		return false, fmt.Errorf("`\033[1m%s\033[0m` is expected to start with `\033[1m%s\033[0m`", string(p.rest), "12345")
	}

	// Take until ' ' as Rest(int32)
	pos = strings.IndexByte(p.rest, ' ')
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Rest", ' ', string(p.rest))
	}
	if tmpInt, err = strconv.ParseInt(tmp, 10, 32); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Rest = int32(tmpInt)

	return true, nil
}

// FixedLook ...
type FixedLook struct {
	rest string
	Data int32
	Rest int32
}

// Extract ...
func (p *FixedLook) Extract(line string) (bool, error) {
	p.rest = line
	var err error
	var pos int
	var tmp string
	var tmpInt int64

	// Take until 3rd character if it starts "123456789" substring as Data(int32)
	if len(p.rest) >= len(const123456789)+2 && strings.HasPrefix(p.rest[2:], const123456789) {
		pos = 2
	} else {
		pos = -1
	}
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(const123456789):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Data", const123456789, string(p.rest[2:2]))
	}
	if tmpInt, err = strconv.ParseInt(tmp, 10, 32); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Data = int32(tmpInt)

	// Take until 4th character if it starts "34" substring as Rest(int32)
	if len(p.rest) >= len(const34)+3 && strings.HasPrefix(p.rest[3:], const34) {
		pos = 3
	} else {
		pos = -1
	}
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(const34):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Rest", const34, string(p.rest[3:3]))
	}
	if tmpInt, err = strconv.ParseInt(tmp, 10, 32); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Rest = int32(tmpInt)

	return true, nil
}

// AnonymousAreas ...
type AnonymousAreas struct {
	rest string
	Data string
}

// Extract ...
func (p *AnonymousAreas) Extract(line string) (bool, error) {
	p.rest = line
	var pos int
	var rest1 string
	rest1 = p.rest

	// Looking for 'd' and then pass it
	pos = -1
	for i, char := range rest1 {
		if char == 'd' {
			pos = i
			break
		}
	}
	if pos >= 0 {
		rest1 = rest1[pos+1:]
	} else {
		goto anonymousareasAnonymousAreaLabel
	}

	// Checks if the rest starts with `"ata="` and pass it
	if strings.HasPrefix(rest1, ataEq) {
		rest1 = rest1[len(ataEq):]
	} else {
		goto anonymousareasAnonymousAreaLabel
	}
	p.rest = rest1
anonymousareasAnonymousAreaLabel:
	rest1 = p.rest

	// Checks if the rest starts with `"1234"` and pass it
	if strings.HasPrefix(rest1, const1234) {
		rest1 = rest1[len(const1234):]
	} else {
		goto anonymousareasAnonymousAreaLabel2
	}
	p.rest = rest1
anonymousareasAnonymousAreaLabel2:

	// Take until " " (or all the rest if not found) as Data(string)
	pos = strings.Index(p.rest, space)
	if pos >= 0 {
		p.Data = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		p.Data = p.rest
		p.rest = p.rest[len(p.rest):]
	}

	return true, nil
}

// Split ...
type Split struct {
	rest  string
	Name  string
	Count string
}

// Extract ...
func (p *Split) Extract(line string) (bool, error) {
	p.rest = line
	var pos int

	// Take until '|' as Name(string)
	pos = -1
	for i, char := range p.rest {
		if char == '|' {
			pos = i
			break
		}
	}
	if pos >= 0 {
		p.Name = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Name", '|', string(p.rest))
	}

	// Checks if rest[1:] starts with '|' and pass it
	if len(p.rest) >= 1+1 && p.rest[1] == '|' {
		p.rest = p.rest[1+1:]
	} else {
		return false, fmt.Errorf("`\033[1m%s\033[0m)` is expected to start with \033[1m%s\033[0m", string(p.rest), '|')
	}

	// Checks if rest[1:] starts with '|' and pass it
	if len(p.rest) >= 1+1 && p.rest[1] == '|' {
		p.rest = p.rest[1+1:]
	} else {
		return false, fmt.Errorf("`\033[1m%s\033[0m)` is expected to start with \033[1m%s\033[0m", string(p.rest), '|')
	}

	// Checks if rest[1:] starts with '|' and pass it
	if len(p.rest) >= 1+1 && p.rest[1] == '|' {
		p.rest = p.rest[1+1:]
	} else {
		return false, fmt.Errorf("`\033[1m%s\033[0m)` is expected to start with \033[1m%s\033[0m", string(p.rest), '|')
	}

	// Take until 2nd character if it is'|' as Count(string)
	if len(p.rest) >= 1+1 && p.rest[1] == '|' {
		pos = 1
	} else {
		pos = -1
	}
	if pos >= 0 {
		p.Count = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Count", '|', string(p.rest[1:1]))
	}

	return true, nil
}

// Shift1 ...
type Shift1 struct {
	rest string
	B    string
}

// Extract ...
func (p *Shift1) Extract(line string) (bool, error) {
	p.rest = line
	var pos int

	// Take until "ba" as B(string)
	if len(p.rest) < 12 {
		return false, fmt.Errorf("Cannot slice up to %d as only %d characters left in the rest (`\033[1m%s\033[0m`)", 12, len(p.rest), string(p.rest))
	}
	pos = strings.Index(p.rest[3:12], ba)
	if pos >= 0 {
		p.B = p.rest[:pos+3]
		p.rest = p.rest[pos+len(ba)+3:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field B", ba, string(p.rest[3:12]))
	}

	return true, nil
}

// Shift2 ...
type Shift2 struct {
	rest string
	B    string
}

// Extract ...
func (p *Shift2) Extract(line string) (bool, error) {
	p.rest = line
	var pos int

	// Take until 'b' as B(string)
	if len(p.rest) < 12 {
		return false, fmt.Errorf("Cannot slice up to %d as only %d characters left in the rest (`\033[1m%s\033[0m`)", 12, len(p.rest), string(p.rest))
	}
	pos = strings.IndexByte(p.rest[3:12], 'b')
	if pos >= 0 {
		p.B = p.rest[:pos+3]
		p.rest = p.rest[pos+1+3:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field B", 'b', string(p.rest[3:12]))
	}

	return true, nil
}

// Shift3 ...
type Shift3 struct {
	rest string
	B    string
}

// Extract ...
func (p *Shift3) Extract(line string) (bool, error) {
	p.rest = line
	var pos int

	// Take until "ba" as B(string)
	if len(p.rest) < 12 {
		return false, fmt.Errorf("Cannot slice up to %d as only %d characters left in the rest (`\033[1m%s\033[0m`)", 12, len(p.rest), string(p.rest))
	}
	pos = strings.Index(p.rest[3:12], ba)
	if pos >= 0 {
		p.B = p.rest[:pos+3]
		p.rest = p.rest[pos+len(ba)+3:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field B", ba, string(p.rest[3:12]))
	}

	return true, nil
}

// Shift4 ...
type Shift4 struct {
	rest string
	B    string
}

// Extract ...
func (p *Shift4) Extract(line string) (bool, error) {
	p.rest = line
	var pos int

	// Take until 'b' as B(string)
	if len(p.rest) < 12 {
		return false, fmt.Errorf("Cannot slice up to %d as only %d characters left in the rest (`\033[1m%s\033[0m`)", 12, len(p.rest), string(p.rest))
	}
	pos = -1
	for i, char := range p.rest[3:12] {
		if char == 'b' {
			pos = i
			break
		}
	}
	if pos >= 0 {
		p.B = p.rest[:pos+3]
		p.rest = p.rest[pos+1+3:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field B", 'b', string(p.rest[3:12]))
	}

	return true, nil
}

// Jump ...
type Jump struct {
	rest   string
	First  string
	Second string
	Third  string
	Fourth string
}

// Extract ...
func (p *Jump) Extract(line string) (bool, error) {
	p.rest = line
	var pos int

	// Take until ' ' as First(string)
	if len(p.rest) < 2 {
		return false, fmt.Errorf("Cannot slice from %d as only %d characters left in the rest (`\033[1m%s\033[0m`)", 2, len(p.rest), string(p.rest))
	}
	pos = strings.IndexByte(p.rest[2:], ' ')
	if pos >= 0 {
		p.First = p.rest[:pos+2]
		p.rest = p.rest[pos+1+2:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field First", ' ', string(p.rest[2:]))
	}

	// Take until ' ' as Second(string)
	if len(p.rest) < 2 {
		return false, fmt.Errorf("Cannot slice from %d as only %d characters left in the rest (`\033[1m%s\033[0m`)", 2, len(p.rest), string(p.rest))
	}
	pos = -1
	for i, char := range p.rest[2:] {
		if char == ' ' {
			pos = i
			break
		}
	}
	if pos >= 0 {
		p.Second = p.rest[:pos+2]
		p.rest = p.rest[pos+1+2:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Second", ' ', string(p.rest[2:]))
	}

	// Take until "@@" as Third(string)
	if len(p.rest) < 2 {
		return false, fmt.Errorf("Cannot slice from %d as only %d characters left in the rest (`\033[1m%s\033[0m`)", 2, len(p.rest), string(p.rest))
	}
	pos = strings.Index(p.rest[2:], dogs)
	if pos >= 0 {
		p.Third = p.rest[:pos+2]
		p.rest = p.rest[pos+len(dogs)+2:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Third", dogs, string(p.rest[2:]))
	}

	// Take until "@@" as Fourth(string)
	if len(p.rest) < 2 {
		return false, fmt.Errorf("Cannot slice from %d as only %d characters left in the rest (`\033[1m%s\033[0m`)", 2, len(p.rest), string(p.rest))
	}
	pos = strings.Index(p.rest[2:], dogs)
	if pos >= 0 {
		p.Fourth = p.rest[:pos+2]
		p.rest = p.rest[pos+len(dogs)+2:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Fourth", dogs, string(p.rest[2:]))
	}

	return true, nil
}

// LookupJump ...
type LookupJump struct {
	rest string
}

// Extract ...
func (p *LookupJump) Extract(line string) (bool, error) {
	p.rest = line
	var pos int

	// Looking for ' ' and then pass it
	if len(p.rest) < 2 {
		return false, fmt.Errorf("Cannot slice from %d as only %d characters left in the rest (`\033[1m%s\033[0m`)", 2, len(p.rest), string(p.rest))
	}
	pos = strings.IndexByte(p.rest[2:], ' ')
	if pos >= 0 {
		p.rest = p.rest[pos+1+2:]
	} else {
		return false, fmt.Errorf("Cannot find \033[1m%c\033[0m in `\033[1m%s\033[0m`", ' ', string(p.rest[2:]))
	}

	if len(p.rest) < 2 {
		return false, fmt.Errorf("Cannot slice from %d as only %d characters left in the rest (`\033[1m%s\033[0m`)", 2, len(p.rest), string(p.rest))
	}
	// Looking for "@@" and then pass it
	pos = strings.Index(p.rest[2:], dogs)
	if pos >= 0 {
		p.rest = p.rest[pos+len(dogs)+2:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m`", dogs, string(p.rest[2:]))
	}

	return true, nil
}

// TargetConstraintsCheck ...
type TargetConstraintsCheck struct {
	rest string
}

// Extract ...
func (p *TargetConstraintsCheck) Extract(line string) (bool, error) {
	p.rest = line
	var pos int

	// Looking for ' ' and then pass it
	if len(p.rest) < 1 {
		return false, nil
	}
	pos = strings.IndexByte(p.rest[1:], ' ')
	if pos >= 0 {
		p.rest = p.rest[pos+1+1:]
	} else {
		return false, nil
	}

	// Looking for ' ' and then pass it
	if len(p.rest) < 1 {
		return false, fmt.Errorf("Cannot slice from %d as only %d characters left in the rest (`\033[1m%s\033[0m`)", 1, len(p.rest), string(p.rest))
	}
	pos = strings.IndexByte(p.rest[1:], ' ')
	if pos >= 0 {
		p.rest = p.rest[pos+1+1:]
	} else {
		return false, fmt.Errorf("Cannot find \033[1m%c\033[0m in `\033[1m%s\033[0m`", ' ', string(p.rest[1:]))
	}

	return true, nil
}

// URL ...
type URL struct {
	rest     string
	UserPass struct {
		Valid    bool
		User     string
		Password string
	}
	User struct {
		Valid bool
		User  string
	}
	Host   string
	Port   uint16
	DBName string
}

// Extract ...
func (p *URL) Extract(line string) (bool, error) {
	p.rest = line
	var err error
	var pos int
	var rest1 string
	var tmp string
	var tmpUint uint64
	rest1 = p.rest

	// Take until ':' as User(string)
	if len(rest1) < 1 {
		p.UserPass.Valid = false
		goto urlUserPassLabel
	}
	pos = strings.IndexByte(rest1[1:], ':')
	if pos >= 0 {
		p.UserPass.User = rest1[:pos+1]
		rest1 = rest1[pos+1+1:]
	} else {
		p.UserPass.Valid = false
		goto urlUserPassLabel
	}

	// Take until '@' as Password(string)
	if len(rest1) < 1 {
		p.UserPass.Valid = false
		goto urlUserPassLabel
	}
	pos = strings.IndexByte(rest1[1:], '@')
	if pos >= 0 {
		p.UserPass.Password = rest1[:pos+1]
		rest1 = rest1[pos+1+1:]
	} else {
		p.UserPass.Valid = false
		goto urlUserPassLabel
	}
	p.UserPass.Valid = true
	p.rest = rest1
urlUserPassLabel:
	rest1 = p.rest

	// Take until '@' as User(string)
	if len(rest1) < 1 {
		p.User.Valid = false
		goto urlUserLabel
	}
	pos = strings.IndexByte(rest1[1:], '@')
	if pos >= 0 {
		p.User.User = rest1[:pos+1]
		rest1 = rest1[pos+1+1:]
	} else {
		p.User.Valid = false
		goto urlUserLabel
	}
	p.User.Valid = true
	p.rest = rest1
urlUserLabel:

	// Take until ':' as Host(string)
	if len(p.rest) < 1 {
		return false, nil
	}
	pos = strings.IndexByte(p.rest[1:], ':')
	if pos >= 0 {
		p.Host = p.rest[:pos+1]
		p.rest = p.rest[pos+1+1:]
	} else {
		return false, nil
	}

	// Take until '/' (or all the rest if not found) as Port(uint16)
	pos = strings.IndexByte(p.rest, '/')
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		tmp = p.rest
		p.rest = p.rest[len(p.rest):]
	}
	if tmpUint, err = strconv.ParseUint(tmp, 10, 16); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Port = uint16(tmpUint)

	// Take the rest as DBName(string)
	p.DBName = p.rest
	p.rest = p.rest[len(p.rest):]
	return true, nil
}

// GetUserPassUser ...
func (p *URL) GetUserPassUser() (res string) {
	if p.UserPass.Valid {
		res = p.UserPass.User
	}
	return
}

// GetUserPassPassword ...
func (p *URL) GetUserPassPassword() (res string) {
	if p.UserPass.Valid {
		res = p.UserPass.Password
	}
	return
}

// GetUserUser ...
func (p *URL) GetUserUser() (res string) {
	if p.User.Valid {
		res = p.User.User
	}
	return
}
