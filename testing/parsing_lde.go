
/*
 This file was autogenerated via
 -----------------------------------------------------------------
 ldetool generate --little-endian --package ldetesting parsing.lde
 -----------------------------------------------------------------
 do not touch it with bare hands!
*/

package ldetesting

import (
	"bytes"
	"fmt"
	"strconv"
	"unsafe"
)

var const123456789 = []byte("123456789")
var const34 = []byte("34")
var space = []byte(" ")

// Decoders ...
type Decoders struct {
	rest    []byte
	Int8    int8
	Int16   int16
	Int32   int32
	Int64   int64
	Uint8   uint8
	Uint16  uint16
	Uint32  uint32
	Uint64  uint64
	Float32 float32
	Float64 float64
	String  []byte
}

// Extract ...
func (p *Decoders) Extract(line []byte) (bool, error) {
	p.rest = line
	var err error
	var pos int
	var tmp []byte
	var tmpFloat float64
	var tmpInt int64
	var tmpUint uint64

	// Take until ' ' as Int8(int8)
	pos = bytes.IndexByte(p.rest, ' ')
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 8); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Int8 = int8(tmpInt)

	// Take until ' ' as Int16(int16)
	pos = bytes.IndexByte(p.rest, ' ')
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 16); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Int16 = int16(tmpInt)

	// Take until ' ' as Int32(int32)
	pos = bytes.IndexByte(p.rest, ' ')
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Int32 = int32(tmpInt)

	// Take until ' ' as Int64(int64)
	pos = bytes.IndexByte(p.rest, ' ')
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Int64 = int64(tmpInt)

	// Take until ' ' as Uint8(uint8)
	pos = bytes.IndexByte(p.rest, ' ')
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 8); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Uint8 = uint8(tmpUint)

	// Take until ' ' as Uint16(uint16)
	pos = bytes.IndexByte(p.rest, ' ')
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 16); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Uint16 = uint16(tmpUint)

	// Take until ' ' as Uint32(uint32)
	pos = bytes.IndexByte(p.rest, ' ')
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Uint32 = uint32(tmpUint)

	// Take until ' ' as Uint64(uint64)
	pos = bytes.IndexByte(p.rest, ' ')
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Uint64 = uint64(tmpUint)

	// Take until ' ' as Float32(float32)
	pos = bytes.IndexByte(p.rest, ' ')
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpFloat, err = strconv.ParseFloat(*(*string)(unsafe.Pointer(&tmp)), 32); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Float32 = float32(tmpFloat)

	// Take until ' ' as Float64(float64)
	pos = bytes.IndexByte(p.rest, ' ')
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpFloat, err = strconv.ParseFloat(*(*string)(unsafe.Pointer(&tmp)), 64); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Float64 = float64(tmpFloat)

	// Take until ' ' as String(string)
	pos = bytes.IndexByte(p.rest, ' ')
	if pos >= 0 {
		p.String = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}

	return true, nil
}

// DecodersLimited ...
type DecodersLimited struct {
	rest    []byte
	Int8    int8
	Int16   int16
	Int32   int32
	Int64   int64
	Uint8   uint8
	Uint16  uint16
	Uint32  uint32
	Uint64  uint64
	Float32 float32
	Float64 float64
	String  []byte
}

// Extract ...
func (p *DecodersLimited) Extract(line []byte) (bool, error) {
	p.rest = line
	var err error
	var pos int
	var tmp []byte
	var tmpFloat float64
	var tmpInt int64
	var tmpUint uint64

	// Take until ' ' as Int8(int8)
	pos = bytes.IndexByte(p.rest[:8], ' ')
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 8); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Int8 = int8(tmpInt)

	// Take until ' ' as Int16(int16)
	pos = bytes.IndexByte(p.rest[:8], ' ')
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 16); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Int16 = int16(tmpInt)

	// Take until ' ' as Int32(int32)
	pos = bytes.IndexByte(p.rest[:8], ' ')
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Int32 = int32(tmpInt)

	// Take until ' ' as Int64(int64)
	pos = bytes.IndexByte(p.rest[:8], ' ')
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Int64 = int64(tmpInt)

	// Take until ' ' as Uint8(uint8)
	pos = bytes.IndexByte(p.rest[:8], ' ')
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 8); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Uint8 = uint8(tmpUint)

	// Take until ' ' as Uint16(uint16)
	pos = bytes.IndexByte(p.rest[:8], ' ')
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 16); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Uint16 = uint16(tmpUint)

	// Take until ' ' as Uint32(uint32)
	pos = bytes.IndexByte(p.rest[:8], ' ')
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Uint32 = uint32(tmpUint)

	// Take until ' ' as Uint64(uint64)
	pos = bytes.IndexByte(p.rest[:8], ' ')
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Uint64 = uint64(tmpUint)

	// Take until ' ' as Float32(float32)
	pos = bytes.IndexByte(p.rest[:8], ' ')
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpFloat, err = strconv.ParseFloat(*(*string)(unsafe.Pointer(&tmp)), 32); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Float32 = float32(tmpFloat)

	// Take until ' ' as Float64(float64)
	pos = bytes.IndexByte(p.rest[:8], ' ')
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpFloat, err = strconv.ParseFloat(*(*string)(unsafe.Pointer(&tmp)), 64); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Float64 = float64(tmpFloat)

	// Take until ' ' as String(string)
	pos = bytes.IndexByte(p.rest[:8], ' ')
	if pos >= 0 {
		p.String = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}

	return true, nil
}

// DecodersBounded ...
type DecodersBounded struct {
	rest  []byte
	Int64 int64
}

// Extract ...
func (p *DecodersBounded) Extract(line []byte) (bool, error) {
	p.rest = line
	var err error
	var pos int
	var tmp []byte
	var tmpInt int64

	// Take until ' ' as Int64(int64)
	pos = bytes.IndexByte(p.rest[8:16], ' ') + 8
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Int64 = int64(tmpInt)

	return true, nil
}

// DecodersString ...
type DecodersString struct {
	rest    []byte
	Int8    int8
	Int16   int16
	Int32   int32
	Int64   int64
	Uint8   uint8
	Uint16  uint16
	Uint32  uint32
	Uint64  uint64
	Float32 float32
	Float64 float64
	String  []byte
}

// Extract ...
func (p *DecodersString) Extract(line []byte) (bool, error) {
	p.rest = line
	var err error
	var pos int
	var tmp []byte
	var tmpFloat float64
	var tmpInt int64
	var tmpUint uint64

	// Take until " " as Int8(int8)
	pos = bytes.Index(p.rest, space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 8); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Int8 = int8(tmpInt)

	// Take until " " as Int16(int16)
	pos = bytes.Index(p.rest, space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 16); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Int16 = int16(tmpInt)

	// Take until " " as Int32(int32)
	pos = bytes.Index(p.rest, space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Int32 = int32(tmpInt)

	// Take until " " as Int64(int64)
	pos = bytes.Index(p.rest, space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Int64 = int64(tmpInt)

	// Take until " " as Uint8(uint8)
	pos = bytes.Index(p.rest, space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 8); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Uint8 = uint8(tmpUint)

	// Take until " " as Uint16(uint16)
	pos = bytes.Index(p.rest, space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 16); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Uint16 = uint16(tmpUint)

	// Take until " " as Uint32(uint32)
	pos = bytes.Index(p.rest, space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Uint32 = uint32(tmpUint)

	// Take until " " as Uint64(uint64)
	pos = bytes.Index(p.rest, space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Uint64 = uint64(tmpUint)

	// Take until " " as Float32(float32)
	pos = bytes.Index(p.rest, space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}
	if tmpFloat, err = strconv.ParseFloat(*(*string)(unsafe.Pointer(&tmp)), 32); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Float32 = float32(tmpFloat)

	// Take until " " as Float64(float64)
	pos = bytes.Index(p.rest, space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}
	if tmpFloat, err = strconv.ParseFloat(*(*string)(unsafe.Pointer(&tmp)), 64); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Float64 = float64(tmpFloat)

	// Take until " " as String(string)
	pos = bytes.Index(p.rest, space)
	if pos >= 0 {
		p.String = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}

	return true, nil
}

// DecodersLimitedString ...
type DecodersLimitedString struct {
	rest    []byte
	Int8    int8
	Int16   int16
	Int32   int32
	Int64   int64
	Uint8   uint8
	Uint16  uint16
	Uint32  uint32
	Uint64  uint64
	Float32 float32
	Float64 float64
	String  []byte
}

// Extract ...
func (p *DecodersLimitedString) Extract(line []byte) (bool, error) {
	p.rest = line
	var err error
	var pos int
	var tmp []byte
	var tmpFloat float64
	var tmpInt int64
	var tmpUint uint64

	// Take until " " as Int8(int8)
	pos = bytes.Index(p.rest[:8], space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 8); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Int8 = int8(tmpInt)

	// Take until " " as Int16(int16)
	pos = bytes.Index(p.rest[:8], space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 16); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Int16 = int16(tmpInt)

	// Take until " " as Int32(int32)
	pos = bytes.Index(p.rest[:8], space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Int32 = int32(tmpInt)

	// Take until " " as Int64(int64)
	pos = bytes.Index(p.rest[:8], space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Int64 = int64(tmpInt)

	// Take until " " as Uint8(uint8)
	pos = bytes.Index(p.rest[:8], space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 8); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Uint8 = uint8(tmpUint)

	// Take until " " as Uint16(uint16)
	pos = bytes.Index(p.rest[:8], space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 16); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Uint16 = uint16(tmpUint)

	// Take until " " as Uint32(uint32)
	pos = bytes.Index(p.rest[:8], space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Uint32 = uint32(tmpUint)

	// Take until " " as Uint64(uint64)
	pos = bytes.Index(p.rest[:8], space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Uint64 = uint64(tmpUint)

	// Take until " " as Float32(float32)
	pos = bytes.Index(p.rest[:8], space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}
	if tmpFloat, err = strconv.ParseFloat(*(*string)(unsafe.Pointer(&tmp)), 32); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Float32 = float32(tmpFloat)

	// Take until " " as Float64(float64)
	pos = bytes.Index(p.rest[:8], space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}
	if tmpFloat, err = strconv.ParseFloat(*(*string)(unsafe.Pointer(&tmp)), 64); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Float64 = float64(tmpFloat)

	// Take until " " as String(string)
	pos = bytes.Index(p.rest[:8], space)
	if pos >= 0 {
		p.String = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}

	return true, nil
}

// DecodersBoundedString ...
type DecodersBoundedString struct {
	rest    []byte
	Float64 float64
}

// Extract ...
func (p *DecodersBoundedString) Extract(line []byte) (bool, error) {
	p.rest = line
	var err error
	var pos int
	var tmp []byte
	var tmpFloat float64

	// Take until " " as Float64(float64)
	pos = bytes.Index(p.rest[8:16], space) + 8
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}
	if tmpFloat, err = strconv.ParseFloat(*(*string)(unsafe.Pointer(&tmp)), 64); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Float64 = float64(tmpFloat)

	return true, nil
}

// DecodersStress ...
type DecodersStress struct {
	rest    []byte
	Int8    int8
	Int16   int16
	Int32   int32
	Int64   int64
	Uint8   uint8
	Uint16  uint16
	Uint32  uint32
	Uint64  uint64
	Float32 float32
	Float64 float64
	String  []byte
}

// Extract ...
func (p *DecodersStress) Extract(line []byte) (bool, error) {
	p.rest = line
	var err error
	var pos int
	var tmp []byte
	var tmpFloat float64
	var tmpInt int64
	var tmpUint uint64

	// Take until ' ' as Int8(int8)
	pos = bytes.IndexByte(p.rest, ' ')
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Int8", ' ', string(p.rest))
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 8); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Int8 = int8(tmpInt)

	// Take until ' ' as Int16(int16)
	pos = bytes.IndexByte(p.rest, ' ')
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Int16", ' ', string(p.rest))
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 16); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Int16 = int16(tmpInt)

	// Take until ' ' as Int32(int32)
	pos = bytes.IndexByte(p.rest, ' ')
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Int32", ' ', string(p.rest))
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Int32 = int32(tmpInt)

	// Take until ' ' as Int64(int64)
	pos = bytes.IndexByte(p.rest, ' ')
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Int64", ' ', string(p.rest))
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Int64 = int64(tmpInt)

	// Take until ' ' as Uint8(uint8)
	pos = bytes.IndexByte(p.rest, ' ')
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint8", ' ', string(p.rest))
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 8); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Uint8 = uint8(tmpUint)

	// Take until ' ' as Uint16(uint16)
	pos = bytes.IndexByte(p.rest, ' ')
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint16", ' ', string(p.rest))
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 16); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Uint16 = uint16(tmpUint)

	// Take until ' ' as Uint32(uint32)
	pos = bytes.IndexByte(p.rest, ' ')
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint32", ' ', string(p.rest))
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Uint32 = uint32(tmpUint)

	// Take until ' ' as Uint64(uint64)
	pos = bytes.IndexByte(p.rest, ' ')
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint64", ' ', string(p.rest))
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Uint64 = uint64(tmpUint)

	// Take until ' ' as Float32(float32)
	pos = bytes.IndexByte(p.rest, ' ')
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Float32", ' ', string(p.rest))
	}
	if tmpFloat, err = strconv.ParseFloat(*(*string)(unsafe.Pointer(&tmp)), 32); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Float32 = float32(tmpFloat)

	// Take until ' ' as Float64(float64)
	pos = bytes.IndexByte(p.rest, ' ')
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Float64", ' ', string(p.rest))
	}
	if tmpFloat, err = strconv.ParseFloat(*(*string)(unsafe.Pointer(&tmp)), 64); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Float64 = float64(tmpFloat)

	// Take until ' ' as String(string)
	pos = bytes.IndexByte(p.rest, ' ')
	if pos >= 0 {
		p.String = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field String", ' ', string(p.rest))
	}

	return true, nil
}

// DecodersLimitedStress ...
type DecodersLimitedStress struct {
	rest    []byte
	Int8    int8
	Int16   int16
	Int32   int32
	Int64   int64
	Uint8   uint8
	Uint16  uint16
	Uint32  uint32
	Uint64  uint64
	Float32 float32
	Float64 float64
	String  []byte
}

// Extract ...
func (p *DecodersLimitedStress) Extract(line []byte) (bool, error) {
	p.rest = line
	var err error
	var pos int
	var tmp []byte
	var tmpFloat float64
	var tmpInt int64
	var tmpUint uint64

	// Take until ' ' as Int8(int8)
	pos = bytes.IndexByte(p.rest[:8], ' ')
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Int8", ' ', string(p.rest[:8]))
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 8); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Int8 = int8(tmpInt)

	// Take until ' ' as Int16(int16)
	pos = bytes.IndexByte(p.rest[:8], ' ')
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Int16", ' ', string(p.rest[:8]))
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 16); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Int16 = int16(tmpInt)

	// Take until ' ' as Int32(int32)
	pos = bytes.IndexByte(p.rest[:8], ' ')
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Int32", ' ', string(p.rest[:8]))
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Int32 = int32(tmpInt)

	// Take until ' ' as Int64(int64)
	pos = bytes.IndexByte(p.rest[:8], ' ')
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Int64", ' ', string(p.rest[:8]))
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Int64 = int64(tmpInt)

	// Take until ' ' as Uint8(uint8)
	pos = bytes.IndexByte(p.rest[:8], ' ')
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint8", ' ', string(p.rest[:8]))
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 8); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Uint8 = uint8(tmpUint)

	// Take until ' ' as Uint16(uint16)
	pos = bytes.IndexByte(p.rest[:8], ' ')
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint16", ' ', string(p.rest[:8]))
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 16); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Uint16 = uint16(tmpUint)

	// Take until ' ' as Uint32(uint32)
	pos = bytes.IndexByte(p.rest[:8], ' ')
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint32", ' ', string(p.rest[:8]))
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Uint32 = uint32(tmpUint)

	// Take until ' ' as Uint64(uint64)
	pos = bytes.IndexByte(p.rest[:8], ' ')
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint64", ' ', string(p.rest[:8]))
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Uint64 = uint64(tmpUint)

	// Take until ' ' as Float32(float32)
	pos = bytes.IndexByte(p.rest[:8], ' ')
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Float32", ' ', string(p.rest[:8]))
	}
	if tmpFloat, err = strconv.ParseFloat(*(*string)(unsafe.Pointer(&tmp)), 32); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Float32 = float32(tmpFloat)

	// Take until ' ' as Float64(float64)
	pos = bytes.IndexByte(p.rest[:8], ' ')
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Float64", ' ', string(p.rest[:8]))
	}
	if tmpFloat, err = strconv.ParseFloat(*(*string)(unsafe.Pointer(&tmp)), 64); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Float64 = float64(tmpFloat)

	// Take until ' ' as String(string)
	pos = bytes.IndexByte(p.rest[:8], ' ')
	if pos >= 0 {
		p.String = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field String", ' ', string(p.rest[:8]))
	}

	return true, nil
}

// DecodersBoundedStress ...
type DecodersBoundedStress struct {
	rest  []byte
	Int64 int64
}

// Extract ...
func (p *DecodersBoundedStress) Extract(line []byte) (bool, error) {
	p.rest = line
	var err error
	var pos int
	var tmp []byte
	var tmpInt int64

	// Take until ' ' as Int64(int64)
	pos = bytes.IndexByte(p.rest[8:16], ' ') + 8
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Int64", ' ', string(p.rest[8:16]))
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Int64 = int64(tmpInt)

	return true, nil
}

// DecodersStringStress ...
type DecodersStringStress struct {
	rest    []byte
	Int8    int8
	Int16   int16
	Int32   int32
	Int64   int64
	Uint8   uint8
	Uint16  uint16
	Uint32  uint32
	Uint64  uint64
	Float32 float32
	Float64 float64
	String  []byte
}

// Extract ...
func (p *DecodersStringStress) Extract(line []byte) (bool, error) {
	p.rest = line
	var err error
	var pos int
	var tmp []byte
	var tmpFloat float64
	var tmpInt int64
	var tmpUint uint64

	// Take until " " as Int8(int8)
	pos = bytes.Index(p.rest, space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Int8", space, string(p.rest))
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 8); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Int8 = int8(tmpInt)

	// Take until " " as Int16(int16)
	pos = bytes.Index(p.rest, space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Int16", space, string(p.rest))
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 16); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Int16 = int16(tmpInt)

	// Take until " " as Int32(int32)
	pos = bytes.Index(p.rest, space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Int32", space, string(p.rest))
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Int32 = int32(tmpInt)

	// Take until " " as Int64(int64)
	pos = bytes.Index(p.rest, space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Int64", space, string(p.rest))
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Int64 = int64(tmpInt)

	// Take until " " as Uint8(uint8)
	pos = bytes.Index(p.rest, space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint8", space, string(p.rest))
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 8); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Uint8 = uint8(tmpUint)

	// Take until " " as Uint16(uint16)
	pos = bytes.Index(p.rest, space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint16", space, string(p.rest))
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 16); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Uint16 = uint16(tmpUint)

	// Take until " " as Uint32(uint32)
	pos = bytes.Index(p.rest, space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint32", space, string(p.rest))
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Uint32 = uint32(tmpUint)

	// Take until " " as Uint64(uint64)
	pos = bytes.Index(p.rest, space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint64", space, string(p.rest))
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Uint64 = uint64(tmpUint)

	// Take until " " as Float32(float32)
	pos = bytes.Index(p.rest, space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Float32", space, string(p.rest))
	}
	if tmpFloat, err = strconv.ParseFloat(*(*string)(unsafe.Pointer(&tmp)), 32); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Float32 = float32(tmpFloat)

	// Take until " " as Float64(float64)
	pos = bytes.Index(p.rest, space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Float64", space, string(p.rest))
	}
	if tmpFloat, err = strconv.ParseFloat(*(*string)(unsafe.Pointer(&tmp)), 64); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Float64 = float64(tmpFloat)

	// Take until " " as String(string)
	pos = bytes.Index(p.rest, space)
	if pos >= 0 {
		p.String = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field String", space, string(p.rest))
	}

	return true, nil
}

// DecodersLimitedStringStress ...
type DecodersLimitedStringStress struct {
	rest    []byte
	Int8    int8
	Int16   int16
	Int32   int32
	Int64   int64
	Uint8   uint8
	Uint16  uint16
	Uint32  uint32
	Uint64  uint64
	Float32 float32
	Float64 float64
	String  []byte
}

// Extract ...
func (p *DecodersLimitedStringStress) Extract(line []byte) (bool, error) {
	p.rest = line
	var err error
	var pos int
	var tmp []byte
	var tmpFloat float64
	var tmpInt int64
	var tmpUint uint64

	// Take until " " as Int8(int8)
	pos = bytes.Index(p.rest[:8], space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Int8", space, string(p.rest[:8]))
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 8); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Int8 = int8(tmpInt)

	// Take until " " as Int16(int16)
	pos = bytes.Index(p.rest[:8], space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Int16", space, string(p.rest[:8]))
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 16); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Int16 = int16(tmpInt)

	// Take until " " as Int32(int32)
	pos = bytes.Index(p.rest[:8], space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Int32", space, string(p.rest[:8]))
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Int32 = int32(tmpInt)

	// Take until " " as Int64(int64)
	pos = bytes.Index(p.rest[:8], space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Int64", space, string(p.rest[:8]))
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Int64 = int64(tmpInt)

	// Take until " " as Uint8(uint8)
	pos = bytes.Index(p.rest[:8], space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint8", space, string(p.rest[:8]))
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 8); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Uint8 = uint8(tmpUint)

	// Take until " " as Uint16(uint16)
	pos = bytes.Index(p.rest[:8], space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint16", space, string(p.rest[:8]))
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 16); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Uint16 = uint16(tmpUint)

	// Take until " " as Uint32(uint32)
	pos = bytes.Index(p.rest[:8], space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint32", space, string(p.rest[:8]))
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Uint32 = uint32(tmpUint)

	// Take until " " as Uint64(uint64)
	pos = bytes.Index(p.rest[:8], space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint64", space, string(p.rest[:8]))
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Uint64 = uint64(tmpUint)

	// Take until " " as Float32(float32)
	pos = bytes.Index(p.rest[:8], space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Float32", space, string(p.rest[:8]))
	}
	if tmpFloat, err = strconv.ParseFloat(*(*string)(unsafe.Pointer(&tmp)), 32); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Float32 = float32(tmpFloat)

	// Take until " " as Float64(float64)
	pos = bytes.Index(p.rest[:8], space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Float64", space, string(p.rest[:8]))
	}
	if tmpFloat, err = strconv.ParseFloat(*(*string)(unsafe.Pointer(&tmp)), 64); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Float64 = float64(tmpFloat)

	// Take until " " as String(string)
	pos = bytes.Index(p.rest[:8], space)
	if pos >= 0 {
		p.String = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field String", space, string(p.rest[:8]))
	}

	return true, nil
}

// DecodersBoundedStringStress ...
type DecodersBoundedStringStress struct {
	rest    []byte
	Float64 float64
}

// Extract ...
func (p *DecodersBoundedStringStress) Extract(line []byte) (bool, error) {
	p.rest = line
	var err error
	var pos int
	var tmp []byte
	var tmpFloat float64

	// Take until " " as Float64(float64)
	pos = bytes.Index(p.rest[8:16], space) + 8
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Float64", space, string(p.rest[8:16]))
	}
	if tmpFloat, err = strconv.ParseFloat(*(*string)(unsafe.Pointer(&tmp)), 64); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Float64 = float64(tmpFloat)

	return true, nil
}

// DecoderOptionals ...
type DecoderOptionals struct {
	rest []byte
	Int8 int8
	Head struct {
		Valid bool
		Data  []byte
	}
}

// Extract ...
func (p *DecoderOptionals) Extract(line []byte) (bool, error) {
	p.rest = line
	var err error
	var headRest []byte
	var pos int
	var tmp []byte
	var tmpInt int64

	// Take until ' ' as Int8(int8)
	pos = bytes.IndexByte(p.rest, ' ')
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 8); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Int8 = int8(tmpInt)
	headRest = p.rest

	// Checks if the rest starts with `"head="` and pass it
	if len(headRest) >= 5 && *(*uint64)(unsafe.Pointer(&headRest[0]))&1099511627775 == 263677109608 {
		headRest = headRest[5:]
	} else {
		p.Head.Valid = false
		goto decoderoptionalsHeadLabel
	}

	// Take until ' ' as Data(string)
	pos = bytes.IndexByte(headRest, ' ')
	if pos >= 0 {
		p.Head.Data = headRest[:pos]
		headRest = headRest[pos+1:]
	} else {
		p.Head.Valid = false
		goto decoderoptionalsHeadLabel
	}
	p.Head.Valid = true
	p.rest = headRest
decoderoptionalsHeadLabel:

	// Checks if the rest starts with `"end"` and pass it
	if len(p.rest) >= 3 && *(*uint64)(unsafe.Pointer(&p.rest[0]))&16777215 == 6581861 {
		p.rest = p.rest[3:]
	} else {
		return false, nil
	}

	return true, nil
}

// GetHeadData ...
func (p *DecoderOptionals) GetHeadData() (res []byte) {
	if p.Head.Valid {
		res = p.Head.Data
	}
	return
}

// DecoderOptionalsStress ...
type DecoderOptionalsStress struct {
	rest []byte
	Int8 int8
	Head struct {
		Valid bool
		Data  []byte
	}
}

// Extract ...
func (p *DecoderOptionalsStress) Extract(line []byte) (bool, error) {
	p.rest = line
	var err error
	var headRest []byte
	var pos int
	var tmp []byte
	var tmpInt int64

	// Take until ' ' as Int8(int8)
	pos = bytes.IndexByte(p.rest, ' ')
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Int8", ' ', string(p.rest))
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 8); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Int8 = int8(tmpInt)
	headRest = p.rest

	// Checks if the rest starts with `"head="` and pass it
	if len(headRest) >= 5 && *(*uint64)(unsafe.Pointer(&headRest[0]))&1099511627775 == 263677109608 {
		headRest = headRest[5:]
	} else {
		p.Head.Valid = false
		goto decoderoptionalsstressHeadLabel
	}

	// Take until ' ' as Data(string)
	pos = bytes.IndexByte(headRest, ' ')
	if pos >= 0 {
		p.Head.Data = headRest[:pos]
		headRest = headRest[pos+1:]
	} else {
		p.Head.Valid = false
		goto decoderoptionalsstressHeadLabel
	}
	p.Head.Valid = true
	p.rest = headRest
decoderoptionalsstressHeadLabel:

	// Checks if the rest starts with `"end"` and pass it
	if len(p.rest) >= 3 && *(*uint64)(unsafe.Pointer(&p.rest[0]))&16777215 == 6581861 {
		p.rest = p.rest[3:]
	} else {
		return false, fmt.Errorf("`\033[1m%s\033[0m` is expected to start with `\033[1m%s\033[0m`", string(p.rest), "end")
	}

	return true, nil
}

// GetHeadData ...
func (p *DecoderOptionalsStress) GetHeadData() (res []byte) {
	if p.Head.Valid {
		res = p.Head.Data
	}
	return
}

// DecoderBranching ...
type DecoderBranching struct {
	rest []byte
	Head struct {
		Valid bool
		Data  []byte
	}
}

// Extract ...
func (p *DecoderBranching) Extract(line []byte) (bool, error) {
	p.rest = line
	var headRest []byte
	var pos int

	// Checks if the rest starts with `"start "` and pass it
	if len(p.rest) >= 6 && *(*uint64)(unsafe.Pointer(&p.rest[0]))&281474976710655 == 35684507284595 {
		p.rest = p.rest[6:]
	}
	headRest = p.rest

	// Checks if the rest starts with `"head="` and pass it
	if len(headRest) >= 5 && *(*uint64)(unsafe.Pointer(&headRest[0]))&1099511627775 == 263677109608 {
		headRest = headRest[5:]
	}

	// Take until ' ' (or all the rest if not found) as Data(string)
	pos = bytes.IndexByte(headRest, ' ')
	if pos >= 0 {
		p.Head.Data = headRest[:pos]
		headRest = headRest[pos+1:]
	} else {
		p.Head.Data = headRest
		headRest = headRest[len(headRest):]
	}
	p.Head.Valid = true
	p.rest = headRest

	return true, nil
}

// GetHeadData ...
func (p *DecoderBranching) GetHeadData() (res []byte) {
	if p.Head.Valid {
		res = p.Head.Data
	}
	return
}

// DecoderBranchingStress ...
type DecoderBranchingStress struct {
	rest []byte
	Head struct {
		Valid bool
		Data  []byte
	}
}

// Extract ...
func (p *DecoderBranchingStress) Extract(line []byte) (bool, error) {
	p.rest = line
	var headRest []byte
	var pos int

	// Checks if the rest starts with `"start "` and pass it
	if len(p.rest) >= 6 && *(*uint64)(unsafe.Pointer(&p.rest[0]))&281474976710655 == 35684507284595 {
		p.rest = p.rest[6:]
	}
	headRest = p.rest

	// Checks if the rest starts with `"head="` and pass it
	if len(headRest) >= 5 && *(*uint64)(unsafe.Pointer(&headRest[0]))&1099511627775 == 263677109608 {
		headRest = headRest[5:]
	}

	// Take until ' ' (or all the rest if not found) as Data(string)
	pos = bytes.IndexByte(headRest, ' ')
	if pos >= 0 {
		p.Head.Data = headRest[:pos]
		headRest = headRest[pos+1:]
	} else {
		p.Head.Data = headRest
		headRest = headRest[len(headRest):]
	}
	p.Head.Valid = true
	p.rest = headRest

	return true, nil
}

// GetHeadData ...
func (p *DecoderBranchingStress) GetHeadData() (res []byte) {
	if p.Head.Valid {
		res = p.Head.Data
	}
	return
}

// DoubleOpts ...
type DoubleOpts struct {
	rest []byte
	Head struct {
		Valid bool
		Data  []byte
	}
	Rest struct {
		Valid bool
		Data  []byte
	}
}

// Extract ...
func (p *DoubleOpts) Extract(line []byte) (bool, error) {
	p.rest = line
	var headRest []byte
	var pos int
	var restRest []byte
	headRest = p.rest

	// Checks if the rest starts with `"head="` and pass it
	if len(headRest) >= 5 && *(*uint64)(unsafe.Pointer(&headRest[0]))&1099511627775 == 263677109608 {
		headRest = headRest[5:]
	} else {
		p.Head.Valid = false
		goto doubleoptsHeadLabel
	}

	// Take until ' ' (or all the rest if not found) as Data(string)
	pos = bytes.IndexByte(headRest, ' ')
	if pos >= 0 {
		p.Head.Data = headRest[:pos]
		headRest = headRest[pos+1:]
	} else {
		p.Head.Data = headRest
		headRest = headRest[len(headRest):]
	}
	p.Head.Valid = true
	p.rest = headRest
doubleoptsHeadLabel:
	restRest = p.rest

	// Checks if the rest starts with `"rest="` and pass it
	if len(restRest) >= 5 && *(*uint64)(unsafe.Pointer(&restRest[0]))&1099511627775 == 263946724722 {
		restRest = restRest[5:]
	} else {
		p.Rest.Valid = false
		goto doubleoptsRestLabel
	}

	// Take until ' ' (or all the rest if not found) as Data(string)
	pos = bytes.IndexByte(restRest, ' ')
	if pos >= 0 {
		p.Rest.Data = restRest[:pos]
		restRest = restRest[pos+1:]
	} else {
		p.Rest.Data = restRest
		restRest = restRest[len(restRest):]
	}
	p.Rest.Valid = true
	p.rest = restRest
doubleoptsRestLabel:

	return true, nil
}

// GetHeadData ...
func (p *DoubleOpts) GetHeadData() (res []byte) {
	if p.Head.Valid {
		res = p.Head.Data
	}
	return
}

// GetRestData ...
func (p *DoubleOpts) GetRestData() (res []byte) {
	if p.Rest.Valid {
		res = p.Rest.Data
	}
	return
}

// Prefixes ...
type Prefixes struct {
	rest []byte
	Data int32
	Rest int32
}

// Extract ...
func (p *Prefixes) Extract(line []byte) (bool, error) {
	p.rest = line
	var err error
	var pos int
	var tmp []byte
	var tmpInt int64

	// Checks if the rest starts with `"123456789"` and pass it
	if bytes.HasPrefix(p.rest, const123456789) {
		p.rest = p.rest[len(const123456789):]
	} else {
		return false, fmt.Errorf("`\033[1m%s\033[0m` is expected to start with `\033[1m%s\033[0m`", string(p.rest), "123456789")
	}

	// Take until ' ' as Data(int32)
	pos = bytes.IndexByte(p.rest, ' ')
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Data", ' ', string(p.rest))
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Data = int32(tmpInt)

	// Checks if the rest starts with `"12345"` and pass it
	if len(p.rest) >= 5 && *(*uint64)(unsafe.Pointer(&p.rest[0]))&1099511627775 == 228509037105 {
		p.rest = p.rest[5:]
	} else {
		return false, fmt.Errorf("`\033[1m%s\033[0m` is expected to start with `\033[1m%s\033[0m`", string(p.rest), "12345")
	}

	// Take until ' ' as Rest(int32)
	pos = bytes.IndexByte(p.rest, ' ')
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Rest", ' ', string(p.rest))
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Rest = int32(tmpInt)

	return true, nil
}

// FixedLook ...
type FixedLook struct {
	rest []byte
	Data int32
	Rest int32
}

// Extract ...
func (p *FixedLook) Extract(line []byte) (bool, error) {
	p.rest = line
	var err error
	var pos int
	var tmp []byte
	var tmpInt int64

	// Take until 3rd character if it starts "123456789" substring as Data(int32)
	if len(p.rest) >= len(const123456789)+2 && bytes.HasPrefix(p.rest[2:], const123456789) {
		pos = 2
	} else {
		pos = -1
	}
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(const123456789):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Data", const123456789, string(p.rest[2:2]))
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Data = int32(tmpInt)

	// Take until 4th character if it starts "34" substring as Rest(int32)
	if len(p.rest)-3 >= 2 && *(*uint64)(unsafe.Pointer(&p.rest[3]))&65535 == 13363 {
		pos = 3
	} else {
		pos = -1
	}
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(const34):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Rest", const34, string(p.rest[3:3]))
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Rest = int32(tmpInt)

	return true, nil
}

// AnonymousAreas ...
type AnonymousAreas struct {
	rest []byte
	Data []byte
}

// Extract ...
func (p *AnonymousAreas) Extract(line []byte) (bool, error) {
	p.rest = line
	var pos int
	var rest []byte
	rest = p.rest

	// Looking for 'd' and then pass it
	pos = -1
	for i, char := range rest {
		if char == 'd' {
			pos = i
			break
		}
	}
	if pos >= 0 {
		rest = rest[pos+1:]
	} else {
		goto anonymousareasAnonymousAreaLabel
	}

	// Checks if the rest starts with `"ata="` and pass it
	if len(rest) >= 4 && *(*uint64)(unsafe.Pointer(&rest[0]))&4294967295 == 1029796961 {
		rest = rest[4:]
	} else {
		goto anonymousareasAnonymousAreaLabel
	}
	p.rest = rest
anonymousareasAnonymousAreaLabel:
	rest = p.rest

	// Checks if the rest starts with `"1234"` and pass it
	if len(rest) >= 4 && *(*uint64)(unsafe.Pointer(&rest[0]))&4294967295 == 875770417 {
		rest = rest[4:]
	} else {
		goto anonymousareasAnonymousAreaLabel2
	}
	p.rest = rest
anonymousareasAnonymousAreaLabel2:

	// Take until " " (or all the rest if not found) as Data(string)
	pos = bytes.Index(p.rest, space)
	if pos >= 0 {
		p.Data = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		p.Data = p.rest
		p.rest = p.rest[len(p.rest):]
	}

	return true, nil
}
