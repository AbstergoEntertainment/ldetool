/* This file was autogenerated via
 -----------------------------------------------------
 ldetool generate --package ldetesting parsing.scripts
 -----------------------------------------------------
do not touch it with bare hands!
*/

package ldetesting

import (
	"bytes"
	"fmt"
	"strconv"
	"unsafe"
)

var end = []byte("end")
var headEq = []byte("head=")
var restEq = []byte("rest=")
var space = []byte(" ")
var startSpace = []byte("start ")

// Decoders autogenerated parser
type Decoders struct {
	rest    []byte
	Int8    int8
	Int16   int16
	Int32   int32
	Int64   int64
	Uint8   uint8
	Uint16  uint16
	Uint32  uint32
	Uint64  uint64
	Float32 float32
	Float64 float64
	String  []byte
}

// Extract autogenerated method of Decoders
func (p *Decoders) Extract(line []byte) (bool, error) {
	var err error
	var pos int
	var tmp []byte
	var tmpFloat float64
	var tmpInt int64
	var tmpUint uint64
	p.rest = line

	// Take until ' ' as Int8(int8)
	pos = bytes.IndexByte(p.rest, ' ')

	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 8); err != nil {
		fmt.Errorf("error parsing `\033[1m%s\033]0m` value as int8 for field `\033[1mInt8\033[0m`: %s", tmp, err)
	}
	p.Int8 = int8(tmpInt)

	// Take until ' ' as Int16(int16)
	pos = bytes.IndexByte(p.rest, ' ')

	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 16); err != nil {
		fmt.Errorf("error parsing `\033[1m%s\033]0m` value as int16 for field `\033[1mInt16\033[0m`: %s", tmp, err)
	}
	p.Int16 = int16(tmpInt)

	// Take until ' ' as Int32(int32)
	pos = bytes.IndexByte(p.rest, ' ')

	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
		fmt.Errorf("error parsing `\033[1m%s\033]0m` value as int32 for field `\033[1mInt32\033[0m`: %s", tmp, err)
	}
	p.Int32 = int32(tmpInt)

	// Take until ' ' as Int64(int64)
	pos = bytes.IndexByte(p.rest, ' ')

	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
		fmt.Errorf("error parsing `\033[1m%s\033]0m` value as int64 for field `\033[1mInt64\033[0m`: %s", tmp, err)
	}
	p.Int64 = int64(tmpInt)

	// Take until ' ' as Uint8(uint8)
	pos = bytes.IndexByte(p.rest, ' ')

	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 8); err != nil {
		fmt.Errorf("error parsing `\033[1m%s\033]0m` value as uint8 for field `\033[1mUint8\033[0m`: %s", tmp, err)
	}
	p.Uint8 = uint8(tmpUint)

	// Take until ' ' as Uint16(uint16)
	pos = bytes.IndexByte(p.rest, ' ')

	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 16); err != nil {
		fmt.Errorf("error parsing `\033[1m%s\033]0m` value as uint16 for field `\033[1mUint16\033[0m`: %s", tmp, err)
	}
	p.Uint16 = uint16(tmpUint)

	// Take until ' ' as Uint32(uint32)
	pos = bytes.IndexByte(p.rest, ' ')

	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
		fmt.Errorf("error parsing `\033[1m%s\033]0m` value as uint32 for field `\033[1mUint32\033[0m`: %s", tmp, err)
	}
	p.Uint32 = uint32(tmpUint)

	// Take until ' ' as Uint64(uint64)
	pos = bytes.IndexByte(p.rest, ' ')

	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
		fmt.Errorf("error parsing `\033[1m%s\033]0m` value as uint64 for field `\033[1mUint64\033[0m`: %s", tmp, err)
	}
	p.Uint64 = uint64(tmpUint)

	// Take until ' ' as Float32(float32)
	pos = bytes.IndexByte(p.rest, ' ')

	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpFloat, err = strconv.ParseFloat(*(*string)(unsafe.Pointer(&tmp)), 32); err != nil {
		fmt.Errorf("error parsing `\033[1m%s\033]0m` value as float32 for field `\033[1mFloat32\033[0m`: %s", tmp, err)
	}
	p.Float32 = float32(tmpFloat)

	// Take until ' ' as Float64(float64)
	pos = bytes.IndexByte(p.rest, ' ')

	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpFloat, err = strconv.ParseFloat(*(*string)(unsafe.Pointer(&tmp)), 64); err != nil {
		fmt.Errorf("error parsing `\033[1m%s\033]0m` value as float64 for field `\033[1mFloat64\033[0m`: %s", tmp, err)
	}
	p.Float64 = float64(tmpFloat)

	// Take until ' ' as String(string)
	pos = bytes.IndexByte(p.rest, ' ')

	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	p.String = tmp

	return true, nil
}

// DecodersLimited autogenerated parser
type DecodersLimited struct {
	rest    []byte
	Int8    int8
	Int16   int16
	Int32   int32
	Int64   int64
	Uint8   uint8
	Uint16  uint16
	Uint32  uint32
	Uint64  uint64
	Float32 float32
	Float64 float64
	String  []byte
}

// Extract autogenerated method of DecodersLimited
func (p *DecodersLimited) Extract(line []byte) (bool, error) {
	var err error
	var pos int
	var tmp []byte
	var tmpFloat float64
	var tmpInt int64
	var tmpUint uint64
	p.rest = line

	// Take until ' ' as Int8(int8)
	pos = bytes.IndexByte(p.rest[:8], ' ')

	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 8); err != nil {
		fmt.Errorf("error parsing `\033[1m%s\033]0m` value as int8 for field `\033[1mInt8\033[0m`: %s", tmp, err)
	}
	p.Int8 = int8(tmpInt)

	// Take until ' ' as Int16(int16)
	pos = bytes.IndexByte(p.rest[:8], ' ')

	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 16); err != nil {
		fmt.Errorf("error parsing `\033[1m%s\033]0m` value as int16 for field `\033[1mInt16\033[0m`: %s", tmp, err)
	}
	p.Int16 = int16(tmpInt)

	// Take until ' ' as Int32(int32)
	pos = bytes.IndexByte(p.rest[:8], ' ')

	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
		fmt.Errorf("error parsing `\033[1m%s\033]0m` value as int32 for field `\033[1mInt32\033[0m`: %s", tmp, err)
	}
	p.Int32 = int32(tmpInt)

	// Take until ' ' as Int64(int64)
	pos = bytes.IndexByte(p.rest[:8], ' ')

	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
		fmt.Errorf("error parsing `\033[1m%s\033]0m` value as int64 for field `\033[1mInt64\033[0m`: %s", tmp, err)
	}
	p.Int64 = int64(tmpInt)

	// Take until ' ' as Uint8(uint8)
	pos = bytes.IndexByte(p.rest[:8], ' ')

	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 8); err != nil {
		fmt.Errorf("error parsing `\033[1m%s\033]0m` value as uint8 for field `\033[1mUint8\033[0m`: %s", tmp, err)
	}
	p.Uint8 = uint8(tmpUint)

	// Take until ' ' as Uint16(uint16)
	pos = bytes.IndexByte(p.rest[:8], ' ')

	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 16); err != nil {
		fmt.Errorf("error parsing `\033[1m%s\033]0m` value as uint16 for field `\033[1mUint16\033[0m`: %s", tmp, err)
	}
	p.Uint16 = uint16(tmpUint)

	// Take until ' ' as Uint32(uint32)
	pos = bytes.IndexByte(p.rest[:8], ' ')

	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
		fmt.Errorf("error parsing `\033[1m%s\033]0m` value as uint32 for field `\033[1mUint32\033[0m`: %s", tmp, err)
	}
	p.Uint32 = uint32(tmpUint)

	// Take until ' ' as Uint64(uint64)
	pos = bytes.IndexByte(p.rest[:8], ' ')

	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
		fmt.Errorf("error parsing `\033[1m%s\033]0m` value as uint64 for field `\033[1mUint64\033[0m`: %s", tmp, err)
	}
	p.Uint64 = uint64(tmpUint)

	// Take until ' ' as Float32(float32)
	pos = bytes.IndexByte(p.rest[:8], ' ')

	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpFloat, err = strconv.ParseFloat(*(*string)(unsafe.Pointer(&tmp)), 32); err != nil {
		fmt.Errorf("error parsing `\033[1m%s\033]0m` value as float32 for field `\033[1mFloat32\033[0m`: %s", tmp, err)
	}
	p.Float32 = float32(tmpFloat)

	// Take until ' ' as Float64(float64)
	pos = bytes.IndexByte(p.rest[:8], ' ')

	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpFloat, err = strconv.ParseFloat(*(*string)(unsafe.Pointer(&tmp)), 64); err != nil {
		fmt.Errorf("error parsing `\033[1m%s\033]0m` value as float64 for field `\033[1mFloat64\033[0m`: %s", tmp, err)
	}
	p.Float64 = float64(tmpFloat)

	// Take until ' ' as String(string)
	pos = bytes.IndexByte(p.rest[:8], ' ')

	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	p.String = tmp

	return true, nil
}

// DecodersBounded autogenerated parser
type DecodersBounded struct {
	rest  []byte
	Int64 int64
}

// Extract autogenerated method of DecodersBounded
func (p *DecodersBounded) Extract(line []byte) (bool, error) {
	var err error
	var pos int
	var tmp []byte
	var tmpInt int64
	p.rest = line

	// Take until ' ' as Int64(int64)
	pos = bytes.IndexByte(p.rest[8:16], ' ') + 8
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
		fmt.Errorf("error parsing `\033[1m%s\033]0m` value as int64 for field `\033[1mInt64\033[0m`: %s", tmp, err)
	}
	p.Int64 = int64(tmpInt)

	return true, nil
}

// DecodersString autogenerated parser
type DecodersString struct {
	rest    []byte
	Int8    int8
	Int16   int16
	Int32   int32
	Int64   int64
	Uint8   uint8
	Uint16  uint16
	Uint32  uint32
	Uint64  uint64
	Float32 float32
	Float64 float64
	String  []byte
}

// Extract autogenerated method of DecodersString
func (p *DecodersString) Extract(line []byte) (bool, error) {
	var err error
	var pos int
	var tmp []byte
	var tmpFloat float64
	var tmpInt int64
	var tmpUint uint64
	p.rest = line

	// Take until " " as Int8(int8)
	pos = bytes.Index(p.rest, space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 8); err != nil {
		fmt.Errorf("error parsing `\033[1m%s\033]0m` value as int8 for field `\033[1mInt8\033[0m`: %s", tmp, err)
	}
	p.Int8 = int8(tmpInt)

	// Take until " " as Int16(int16)
	pos = bytes.Index(p.rest, space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 16); err != nil {
		fmt.Errorf("error parsing `\033[1m%s\033]0m` value as int16 for field `\033[1mInt16\033[0m`: %s", tmp, err)
	}
	p.Int16 = int16(tmpInt)

	// Take until " " as Int32(int32)
	pos = bytes.Index(p.rest, space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
		fmt.Errorf("error parsing `\033[1m%s\033]0m` value as int32 for field `\033[1mInt32\033[0m`: %s", tmp, err)
	}
	p.Int32 = int32(tmpInt)

	// Take until " " as Int64(int64)
	pos = bytes.Index(p.rest, space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
		fmt.Errorf("error parsing `\033[1m%s\033]0m` value as int64 for field `\033[1mInt64\033[0m`: %s", tmp, err)
	}
	p.Int64 = int64(tmpInt)

	// Take until " " as Uint8(uint8)
	pos = bytes.Index(p.rest, space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 8); err != nil {
		fmt.Errorf("error parsing `\033[1m%s\033]0m` value as uint8 for field `\033[1mUint8\033[0m`: %s", tmp, err)
	}
	p.Uint8 = uint8(tmpUint)

	// Take until " " as Uint16(uint16)
	pos = bytes.Index(p.rest, space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 16); err != nil {
		fmt.Errorf("error parsing `\033[1m%s\033]0m` value as uint16 for field `\033[1mUint16\033[0m`: %s", tmp, err)
	}
	p.Uint16 = uint16(tmpUint)

	// Take until " " as Uint32(uint32)
	pos = bytes.Index(p.rest, space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
		fmt.Errorf("error parsing `\033[1m%s\033]0m` value as uint32 for field `\033[1mUint32\033[0m`: %s", tmp, err)
	}
	p.Uint32 = uint32(tmpUint)

	// Take until " " as Uint64(uint64)
	pos = bytes.Index(p.rest, space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
		fmt.Errorf("error parsing `\033[1m%s\033]0m` value as uint64 for field `\033[1mUint64\033[0m`: %s", tmp, err)
	}
	p.Uint64 = uint64(tmpUint)

	// Take until " " as Float32(float32)
	pos = bytes.Index(p.rest, space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}
	if tmpFloat, err = strconv.ParseFloat(*(*string)(unsafe.Pointer(&tmp)), 32); err != nil {
		fmt.Errorf("error parsing `\033[1m%s\033]0m` value as float32 for field `\033[1mFloat32\033[0m`: %s", tmp, err)
	}
	p.Float32 = float32(tmpFloat)

	// Take until " " as Float64(float64)
	pos = bytes.Index(p.rest, space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}
	if tmpFloat, err = strconv.ParseFloat(*(*string)(unsafe.Pointer(&tmp)), 64); err != nil {
		fmt.Errorf("error parsing `\033[1m%s\033]0m` value as float64 for field `\033[1mFloat64\033[0m`: %s", tmp, err)
	}
	p.Float64 = float64(tmpFloat)

	// Take until " " as String(string)
	pos = bytes.Index(p.rest, space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}
	p.String = tmp

	return true, nil
}

// DecodersLimitedString autogenerated parser
type DecodersLimitedString struct {
	rest    []byte
	Int8    int8
	Int16   int16
	Int32   int32
	Int64   int64
	Uint8   uint8
	Uint16  uint16
	Uint32  uint32
	Uint64  uint64
	Float32 float32
	Float64 float64
	String  []byte
}

// Extract autogenerated method of DecodersLimitedString
func (p *DecodersLimitedString) Extract(line []byte) (bool, error) {
	var err error
	var pos int
	var tmp []byte
	var tmpFloat float64
	var tmpInt int64
	var tmpUint uint64
	p.rest = line

	// Take until " " as Int8(int8)
	pos = bytes.Index(p.rest[:8], space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 8); err != nil {
		fmt.Errorf("error parsing `\033[1m%s\033]0m` value as int8 for field `\033[1mInt8\033[0m`: %s", tmp, err)
	}
	p.Int8 = int8(tmpInt)

	// Take until " " as Int16(int16)
	pos = bytes.Index(p.rest[:8], space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 16); err != nil {
		fmt.Errorf("error parsing `\033[1m%s\033]0m` value as int16 for field `\033[1mInt16\033[0m`: %s", tmp, err)
	}
	p.Int16 = int16(tmpInt)

	// Take until " " as Int32(int32)
	pos = bytes.Index(p.rest[:8], space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
		fmt.Errorf("error parsing `\033[1m%s\033]0m` value as int32 for field `\033[1mInt32\033[0m`: %s", tmp, err)
	}
	p.Int32 = int32(tmpInt)

	// Take until " " as Int64(int64)
	pos = bytes.Index(p.rest[:8], space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
		fmt.Errorf("error parsing `\033[1m%s\033]0m` value as int64 for field `\033[1mInt64\033[0m`: %s", tmp, err)
	}
	p.Int64 = int64(tmpInt)

	// Take until " " as Uint8(uint8)
	pos = bytes.Index(p.rest[:8], space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 8); err != nil {
		fmt.Errorf("error parsing `\033[1m%s\033]0m` value as uint8 for field `\033[1mUint8\033[0m`: %s", tmp, err)
	}
	p.Uint8 = uint8(tmpUint)

	// Take until " " as Uint16(uint16)
	pos = bytes.Index(p.rest[:8], space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 16); err != nil {
		fmt.Errorf("error parsing `\033[1m%s\033]0m` value as uint16 for field `\033[1mUint16\033[0m`: %s", tmp, err)
	}
	p.Uint16 = uint16(tmpUint)

	// Take until " " as Uint32(uint32)
	pos = bytes.Index(p.rest[:8], space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
		fmt.Errorf("error parsing `\033[1m%s\033]0m` value as uint32 for field `\033[1mUint32\033[0m`: %s", tmp, err)
	}
	p.Uint32 = uint32(tmpUint)

	// Take until " " as Uint64(uint64)
	pos = bytes.Index(p.rest[:8], space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
		fmt.Errorf("error parsing `\033[1m%s\033]0m` value as uint64 for field `\033[1mUint64\033[0m`: %s", tmp, err)
	}
	p.Uint64 = uint64(tmpUint)

	// Take until " " as Float32(float32)
	pos = bytes.Index(p.rest[:8], space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}
	if tmpFloat, err = strconv.ParseFloat(*(*string)(unsafe.Pointer(&tmp)), 32); err != nil {
		fmt.Errorf("error parsing `\033[1m%s\033]0m` value as float32 for field `\033[1mFloat32\033[0m`: %s", tmp, err)
	}
	p.Float32 = float32(tmpFloat)

	// Take until " " as Float64(float64)
	pos = bytes.Index(p.rest[:8], space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}
	if tmpFloat, err = strconv.ParseFloat(*(*string)(unsafe.Pointer(&tmp)), 64); err != nil {
		fmt.Errorf("error parsing `\033[1m%s\033]0m` value as float64 for field `\033[1mFloat64\033[0m`: %s", tmp, err)
	}
	p.Float64 = float64(tmpFloat)

	// Take until " " as String(string)
	pos = bytes.Index(p.rest[:8], space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}
	p.String = tmp

	return true, nil
}

// DecodersBoundedString autogenerated parser
type DecodersBoundedString struct {
	rest    []byte
	Float64 float64
}

// Extract autogenerated method of DecodersBoundedString
func (p *DecodersBoundedString) Extract(line []byte) (bool, error) {
	var err error
	var pos int
	var tmp []byte
	var tmpFloat float64
	p.rest = line

	// Take until " " as Float64(float64)
	pos = bytes.Index(p.rest[8:16], space) + 8
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}
	if tmpFloat, err = strconv.ParseFloat(*(*string)(unsafe.Pointer(&tmp)), 64); err != nil {
		fmt.Errorf("error parsing `\033[1m%s\033]0m` value as float64 for field `\033[1mFloat64\033[0m`: %s", tmp, err)
	}
	p.Float64 = float64(tmpFloat)

	return true, nil
}

// DecodersStress autogenerated parser
type DecodersStress struct {
	rest    []byte
	Int8    int8
	Int16   int16
	Int32   int32
	Int64   int64
	Uint8   uint8
	Uint16  uint16
	Uint32  uint32
	Uint64  uint64
	Float32 float32
	Float64 float64
	String  []byte
}

// Extract autogenerated method of DecodersStress
func (p *DecodersStress) Extract(line []byte) (bool, error) {
	var err error
	var pos int
	var tmp []byte
	var tmpFloat float64
	var tmpInt int64
	var tmpUint uint64
	p.rest = line

	// Take until ' ' as Int8(int8)
	pos = bytes.IndexByte(p.rest, ' ')

	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Int8", ' ', p.rest)
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 8); err != nil {
		fmt.Errorf("error parsing `\033[1m%s\033]0m` value as int8 for field `\033[1mInt8\033[0m`: %s", tmp, err)
	}
	p.Int8 = int8(tmpInt)

	// Take until ' ' as Int16(int16)
	pos = bytes.IndexByte(p.rest, ' ')

	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Int16", ' ', p.rest)
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 16); err != nil {
		fmt.Errorf("error parsing `\033[1m%s\033]0m` value as int16 for field `\033[1mInt16\033[0m`: %s", tmp, err)
	}
	p.Int16 = int16(tmpInt)

	// Take until ' ' as Int32(int32)
	pos = bytes.IndexByte(p.rest, ' ')

	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Int32", ' ', p.rest)
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
		fmt.Errorf("error parsing `\033[1m%s\033]0m` value as int32 for field `\033[1mInt32\033[0m`: %s", tmp, err)
	}
	p.Int32 = int32(tmpInt)

	// Take until ' ' as Int64(int64)
	pos = bytes.IndexByte(p.rest, ' ')

	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Int64", ' ', p.rest)
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
		fmt.Errorf("error parsing `\033[1m%s\033]0m` value as int64 for field `\033[1mInt64\033[0m`: %s", tmp, err)
	}
	p.Int64 = int64(tmpInt)

	// Take until ' ' as Uint8(uint8)
	pos = bytes.IndexByte(p.rest, ' ')

	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint8", ' ', p.rest)
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 8); err != nil {
		fmt.Errorf("error parsing `\033[1m%s\033]0m` value as uint8 for field `\033[1mUint8\033[0m`: %s", tmp, err)
	}
	p.Uint8 = uint8(tmpUint)

	// Take until ' ' as Uint16(uint16)
	pos = bytes.IndexByte(p.rest, ' ')

	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint16", ' ', p.rest)
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 16); err != nil {
		fmt.Errorf("error parsing `\033[1m%s\033]0m` value as uint16 for field `\033[1mUint16\033[0m`: %s", tmp, err)
	}
	p.Uint16 = uint16(tmpUint)

	// Take until ' ' as Uint32(uint32)
	pos = bytes.IndexByte(p.rest, ' ')

	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint32", ' ', p.rest)
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
		fmt.Errorf("error parsing `\033[1m%s\033]0m` value as uint32 for field `\033[1mUint32\033[0m`: %s", tmp, err)
	}
	p.Uint32 = uint32(tmpUint)

	// Take until ' ' as Uint64(uint64)
	pos = bytes.IndexByte(p.rest, ' ')

	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint64", ' ', p.rest)
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
		fmt.Errorf("error parsing `\033[1m%s\033]0m` value as uint64 for field `\033[1mUint64\033[0m`: %s", tmp, err)
	}
	p.Uint64 = uint64(tmpUint)

	// Take until ' ' as Float32(float32)
	pos = bytes.IndexByte(p.rest, ' ')

	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Float32", ' ', p.rest)
	}
	if tmpFloat, err = strconv.ParseFloat(*(*string)(unsafe.Pointer(&tmp)), 32); err != nil {
		fmt.Errorf("error parsing `\033[1m%s\033]0m` value as float32 for field `\033[1mFloat32\033[0m`: %s", tmp, err)
	}
	p.Float32 = float32(tmpFloat)

	// Take until ' ' as Float64(float64)
	pos = bytes.IndexByte(p.rest, ' ')

	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Float64", ' ', p.rest)
	}
	if tmpFloat, err = strconv.ParseFloat(*(*string)(unsafe.Pointer(&tmp)), 64); err != nil {
		fmt.Errorf("error parsing `\033[1m%s\033]0m` value as float64 for field `\033[1mFloat64\033[0m`: %s", tmp, err)
	}
	p.Float64 = float64(tmpFloat)

	// Take until ' ' as String(string)
	pos = bytes.IndexByte(p.rest, ' ')

	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field String", ' ', p.rest)
	}
	p.String = tmp

	return true, nil
}

// DecodersLimitedStress autogenerated parser
type DecodersLimitedStress struct {
	rest    []byte
	Int8    int8
	Int16   int16
	Int32   int32
	Int64   int64
	Uint8   uint8
	Uint16  uint16
	Uint32  uint32
	Uint64  uint64
	Float32 float32
	Float64 float64
	String  []byte
}

// Extract autogenerated method of DecodersLimitedStress
func (p *DecodersLimitedStress) Extract(line []byte) (bool, error) {
	var err error
	var pos int
	var tmp []byte
	var tmpFloat float64
	var tmpInt int64
	var tmpUint uint64
	p.rest = line

	// Take until ' ' as Int8(int8)
	pos = bytes.IndexByte(p.rest[:8], ' ')

	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Int8", ' ', p.rest[:8])
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 8); err != nil {
		fmt.Errorf("error parsing `\033[1m%s\033]0m` value as int8 for field `\033[1mInt8\033[0m`: %s", tmp, err)
	}
	p.Int8 = int8(tmpInt)

	// Take until ' ' as Int16(int16)
	pos = bytes.IndexByte(p.rest[:8], ' ')

	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Int16", ' ', p.rest[:8])
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 16); err != nil {
		fmt.Errorf("error parsing `\033[1m%s\033]0m` value as int16 for field `\033[1mInt16\033[0m`: %s", tmp, err)
	}
	p.Int16 = int16(tmpInt)

	// Take until ' ' as Int32(int32)
	pos = bytes.IndexByte(p.rest[:8], ' ')

	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Int32", ' ', p.rest[:8])
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
		fmt.Errorf("error parsing `\033[1m%s\033]0m` value as int32 for field `\033[1mInt32\033[0m`: %s", tmp, err)
	}
	p.Int32 = int32(tmpInt)

	// Take until ' ' as Int64(int64)
	pos = bytes.IndexByte(p.rest[:8], ' ')

	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Int64", ' ', p.rest[:8])
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
		fmt.Errorf("error parsing `\033[1m%s\033]0m` value as int64 for field `\033[1mInt64\033[0m`: %s", tmp, err)
	}
	p.Int64 = int64(tmpInt)

	// Take until ' ' as Uint8(uint8)
	pos = bytes.IndexByte(p.rest[:8], ' ')

	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint8", ' ', p.rest[:8])
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 8); err != nil {
		fmt.Errorf("error parsing `\033[1m%s\033]0m` value as uint8 for field `\033[1mUint8\033[0m`: %s", tmp, err)
	}
	p.Uint8 = uint8(tmpUint)

	// Take until ' ' as Uint16(uint16)
	pos = bytes.IndexByte(p.rest[:8], ' ')

	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint16", ' ', p.rest[:8])
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 16); err != nil {
		fmt.Errorf("error parsing `\033[1m%s\033]0m` value as uint16 for field `\033[1mUint16\033[0m`: %s", tmp, err)
	}
	p.Uint16 = uint16(tmpUint)

	// Take until ' ' as Uint32(uint32)
	pos = bytes.IndexByte(p.rest[:8], ' ')

	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint32", ' ', p.rest[:8])
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
		fmt.Errorf("error parsing `\033[1m%s\033]0m` value as uint32 for field `\033[1mUint32\033[0m`: %s", tmp, err)
	}
	p.Uint32 = uint32(tmpUint)

	// Take until ' ' as Uint64(uint64)
	pos = bytes.IndexByte(p.rest[:8], ' ')

	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint64", ' ', p.rest[:8])
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
		fmt.Errorf("error parsing `\033[1m%s\033]0m` value as uint64 for field `\033[1mUint64\033[0m`: %s", tmp, err)
	}
	p.Uint64 = uint64(tmpUint)

	// Take until ' ' as Float32(float32)
	pos = bytes.IndexByte(p.rest[:8], ' ')

	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Float32", ' ', p.rest[:8])
	}
	if tmpFloat, err = strconv.ParseFloat(*(*string)(unsafe.Pointer(&tmp)), 32); err != nil {
		fmt.Errorf("error parsing `\033[1m%s\033]0m` value as float32 for field `\033[1mFloat32\033[0m`: %s", tmp, err)
	}
	p.Float32 = float32(tmpFloat)

	// Take until ' ' as Float64(float64)
	pos = bytes.IndexByte(p.rest[:8], ' ')

	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Float64", ' ', p.rest[:8])
	}
	if tmpFloat, err = strconv.ParseFloat(*(*string)(unsafe.Pointer(&tmp)), 64); err != nil {
		fmt.Errorf("error parsing `\033[1m%s\033]0m` value as float64 for field `\033[1mFloat64\033[0m`: %s", tmp, err)
	}
	p.Float64 = float64(tmpFloat)

	// Take until ' ' as String(string)
	pos = bytes.IndexByte(p.rest[:8], ' ')

	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field String", ' ', p.rest[:8])
	}
	p.String = tmp

	return true, nil
}

// DecodersBoundedStress autogenerated parser
type DecodersBoundedStress struct {
	rest  []byte
	Int64 int64
}

// Extract autogenerated method of DecodersBoundedStress
func (p *DecodersBoundedStress) Extract(line []byte) (bool, error) {
	var err error
	var pos int
	var tmp []byte
	var tmpInt int64
	p.rest = line

	// Take until ' ' as Int64(int64)
	pos = bytes.IndexByte(p.rest[8:16], ' ') + 8
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Int64", ' ', p.rest[8:16])
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
		fmt.Errorf("error parsing `\033[1m%s\033]0m` value as int64 for field `\033[1mInt64\033[0m`: %s", tmp, err)
	}
	p.Int64 = int64(tmpInt)

	return true, nil
}

// DecodersStringStress autogenerated parser
type DecodersStringStress struct {
	rest    []byte
	Int8    int8
	Int16   int16
	Int32   int32
	Int64   int64
	Uint8   uint8
	Uint16  uint16
	Uint32  uint32
	Uint64  uint64
	Float32 float32
	Float64 float64
	String  []byte
}

// Extract autogenerated method of DecodersStringStress
func (p *DecodersStringStress) Extract(line []byte) (bool, error) {
	var err error
	var pos int
	var tmp []byte
	var tmpFloat float64
	var tmpInt int64
	var tmpUint uint64
	p.rest = line

	// Take until " " as Int8(int8)
	pos = bytes.Index(p.rest, space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Int8", space, p.rest)
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 8); err != nil {
		fmt.Errorf("error parsing `\033[1m%s\033]0m` value as int8 for field `\033[1mInt8\033[0m`: %s", tmp, err)
	}
	p.Int8 = int8(tmpInt)

	// Take until " " as Int16(int16)
	pos = bytes.Index(p.rest, space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Int16", space, p.rest)
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 16); err != nil {
		fmt.Errorf("error parsing `\033[1m%s\033]0m` value as int16 for field `\033[1mInt16\033[0m`: %s", tmp, err)
	}
	p.Int16 = int16(tmpInt)

	// Take until " " as Int32(int32)
	pos = bytes.Index(p.rest, space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Int32", space, p.rest)
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
		fmt.Errorf("error parsing `\033[1m%s\033]0m` value as int32 for field `\033[1mInt32\033[0m`: %s", tmp, err)
	}
	p.Int32 = int32(tmpInt)

	// Take until " " as Int64(int64)
	pos = bytes.Index(p.rest, space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Int64", space, p.rest)
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
		fmt.Errorf("error parsing `\033[1m%s\033]0m` value as int64 for field `\033[1mInt64\033[0m`: %s", tmp, err)
	}
	p.Int64 = int64(tmpInt)

	// Take until " " as Uint8(uint8)
	pos = bytes.Index(p.rest, space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint8", space, p.rest)
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 8); err != nil {
		fmt.Errorf("error parsing `\033[1m%s\033]0m` value as uint8 for field `\033[1mUint8\033[0m`: %s", tmp, err)
	}
	p.Uint8 = uint8(tmpUint)

	// Take until " " as Uint16(uint16)
	pos = bytes.Index(p.rest, space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint16", space, p.rest)
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 16); err != nil {
		fmt.Errorf("error parsing `\033[1m%s\033]0m` value as uint16 for field `\033[1mUint16\033[0m`: %s", tmp, err)
	}
	p.Uint16 = uint16(tmpUint)

	// Take until " " as Uint32(uint32)
	pos = bytes.Index(p.rest, space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint32", space, p.rest)
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
		fmt.Errorf("error parsing `\033[1m%s\033]0m` value as uint32 for field `\033[1mUint32\033[0m`: %s", tmp, err)
	}
	p.Uint32 = uint32(tmpUint)

	// Take until " " as Uint64(uint64)
	pos = bytes.Index(p.rest, space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint64", space, p.rest)
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
		fmt.Errorf("error parsing `\033[1m%s\033]0m` value as uint64 for field `\033[1mUint64\033[0m`: %s", tmp, err)
	}
	p.Uint64 = uint64(tmpUint)

	// Take until " " as Float32(float32)
	pos = bytes.Index(p.rest, space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Float32", space, p.rest)
	}
	if tmpFloat, err = strconv.ParseFloat(*(*string)(unsafe.Pointer(&tmp)), 32); err != nil {
		fmt.Errorf("error parsing `\033[1m%s\033]0m` value as float32 for field `\033[1mFloat32\033[0m`: %s", tmp, err)
	}
	p.Float32 = float32(tmpFloat)

	// Take until " " as Float64(float64)
	pos = bytes.Index(p.rest, space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Float64", space, p.rest)
	}
	if tmpFloat, err = strconv.ParseFloat(*(*string)(unsafe.Pointer(&tmp)), 64); err != nil {
		fmt.Errorf("error parsing `\033[1m%s\033]0m` value as float64 for field `\033[1mFloat64\033[0m`: %s", tmp, err)
	}
	p.Float64 = float64(tmpFloat)

	// Take until " " as String(string)
	pos = bytes.Index(p.rest, space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field String", space, p.rest)
	}
	p.String = tmp

	return true, nil
}

// DecodersLimitedStringStress autogenerated parser
type DecodersLimitedStringStress struct {
	rest    []byte
	Int8    int8
	Int16   int16
	Int32   int32
	Int64   int64
	Uint8   uint8
	Uint16  uint16
	Uint32  uint32
	Uint64  uint64
	Float32 float32
	Float64 float64
	String  []byte
}

// Extract autogenerated method of DecodersLimitedStringStress
func (p *DecodersLimitedStringStress) Extract(line []byte) (bool, error) {
	var err error
	var pos int
	var tmp []byte
	var tmpFloat float64
	var tmpInt int64
	var tmpUint uint64
	p.rest = line

	// Take until " " as Int8(int8)
	pos = bytes.Index(p.rest[:8], space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Int8", space, p.rest[:8])
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 8); err != nil {
		fmt.Errorf("error parsing `\033[1m%s\033]0m` value as int8 for field `\033[1mInt8\033[0m`: %s", tmp, err)
	}
	p.Int8 = int8(tmpInt)

	// Take until " " as Int16(int16)
	pos = bytes.Index(p.rest[:8], space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Int16", space, p.rest[:8])
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 16); err != nil {
		fmt.Errorf("error parsing `\033[1m%s\033]0m` value as int16 for field `\033[1mInt16\033[0m`: %s", tmp, err)
	}
	p.Int16 = int16(tmpInt)

	// Take until " " as Int32(int32)
	pos = bytes.Index(p.rest[:8], space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Int32", space, p.rest[:8])
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
		fmt.Errorf("error parsing `\033[1m%s\033]0m` value as int32 for field `\033[1mInt32\033[0m`: %s", tmp, err)
	}
	p.Int32 = int32(tmpInt)

	// Take until " " as Int64(int64)
	pos = bytes.Index(p.rest[:8], space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Int64", space, p.rest[:8])
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
		fmt.Errorf("error parsing `\033[1m%s\033]0m` value as int64 for field `\033[1mInt64\033[0m`: %s", tmp, err)
	}
	p.Int64 = int64(tmpInt)

	// Take until " " as Uint8(uint8)
	pos = bytes.Index(p.rest[:8], space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint8", space, p.rest[:8])
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 8); err != nil {
		fmt.Errorf("error parsing `\033[1m%s\033]0m` value as uint8 for field `\033[1mUint8\033[0m`: %s", tmp, err)
	}
	p.Uint8 = uint8(tmpUint)

	// Take until " " as Uint16(uint16)
	pos = bytes.Index(p.rest[:8], space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint16", space, p.rest[:8])
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 16); err != nil {
		fmt.Errorf("error parsing `\033[1m%s\033]0m` value as uint16 for field `\033[1mUint16\033[0m`: %s", tmp, err)
	}
	p.Uint16 = uint16(tmpUint)

	// Take until " " as Uint32(uint32)
	pos = bytes.Index(p.rest[:8], space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint32", space, p.rest[:8])
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
		fmt.Errorf("error parsing `\033[1m%s\033]0m` value as uint32 for field `\033[1mUint32\033[0m`: %s", tmp, err)
	}
	p.Uint32 = uint32(tmpUint)

	// Take until " " as Uint64(uint64)
	pos = bytes.Index(p.rest[:8], space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint64", space, p.rest[:8])
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
		fmt.Errorf("error parsing `\033[1m%s\033]0m` value as uint64 for field `\033[1mUint64\033[0m`: %s", tmp, err)
	}
	p.Uint64 = uint64(tmpUint)

	// Take until " " as Float32(float32)
	pos = bytes.Index(p.rest[:8], space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Float32", space, p.rest[:8])
	}
	if tmpFloat, err = strconv.ParseFloat(*(*string)(unsafe.Pointer(&tmp)), 32); err != nil {
		fmt.Errorf("error parsing `\033[1m%s\033]0m` value as float32 for field `\033[1mFloat32\033[0m`: %s", tmp, err)
	}
	p.Float32 = float32(tmpFloat)

	// Take until " " as Float64(float64)
	pos = bytes.Index(p.rest[:8], space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Float64", space, p.rest[:8])
	}
	if tmpFloat, err = strconv.ParseFloat(*(*string)(unsafe.Pointer(&tmp)), 64); err != nil {
		fmt.Errorf("error parsing `\033[1m%s\033]0m` value as float64 for field `\033[1mFloat64\033[0m`: %s", tmp, err)
	}
	p.Float64 = float64(tmpFloat)

	// Take until " " as String(string)
	pos = bytes.Index(p.rest[:8], space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field String", space, p.rest[:8])
	}
	p.String = tmp

	return true, nil
}

// DecodersBoundedStringStress autogenerated parser
type DecodersBoundedStringStress struct {
	rest    []byte
	Float64 float64
}

// Extract autogenerated method of DecodersBoundedStringStress
func (p *DecodersBoundedStringStress) Extract(line []byte) (bool, error) {
	var err error
	var pos int
	var tmp []byte
	var tmpFloat float64
	p.rest = line

	// Take until " " as Float64(float64)
	pos = bytes.Index(p.rest[8:16], space) + 8
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Float64", space, p.rest[8:16])
	}
	if tmpFloat, err = strconv.ParseFloat(*(*string)(unsafe.Pointer(&tmp)), 64); err != nil {
		fmt.Errorf("error parsing `\033[1m%s\033]0m` value as float64 for field `\033[1mFloat64\033[0m`: %s", tmp, err)
	}
	p.Float64 = float64(tmpFloat)

	return true, nil
}

// DecoderOptionals autogenerated parser
type DecoderOptionals struct {
	rest []byte
	Int8 int8
	Head struct {
		Valid bool
		Data  []byte
	}
}

// Extract autogenerated method of DecoderOptionals
func (p *DecoderOptionals) Extract(line []byte) (bool, error) {
	var err error
	var headRest []byte
	var pos int
	var tmp []byte
	var tmpInt int64
	p.rest = line

	// Take until ' ' as Int8(int8)
	pos = bytes.IndexByte(p.rest, ' ')

	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 8); err != nil {
		fmt.Errorf("error parsing `\033[1m%s\033]0m` value as int8 for field `\033[1mInt8\033[0m`: %s", tmp, err)
	}
	p.Int8 = int8(tmpInt)
	headRest = p.rest

	// Checks if the rest starts with `"head="` and pass it
	if bytes.HasPrefix(headRest, headEq) {
		headRest = headRest[len(headEq):]
	} else {
		goto headLabel
	}

	// Take until ' ' as Data(string)
	pos = bytes.IndexByte(headRest, ' ')

	if pos >= 0 {
		tmp = headRest[:pos]
		headRest = headRest[pos+1:]
	} else {
		p.Head.Valid = false
		goto headLabel
	}
	p.Head.Data = tmp
	p.Head.Valid = true
	p.Head.Valid = true
	p.rest = headRest

	// Checks if the rest starts with `"end"` and pass it
	if bytes.HasPrefix(p.rest, end) {
		p.rest = p.rest[len(end):]
	} else {
		return false, nil
	}

	return true, nil
}

// GetHeadData retrieves optional value for HeadData.Name
func (p *DecoderOptionals) GetHeadData() (res []byte) {
	if !p.Head.Valid {
		return
	}
	return p.Head.Data
}

// DecoderOptionalsStress autogenerated parser
type DecoderOptionalsStress struct {
	rest []byte
	Int8 int8
	Head struct {
		Valid bool
		Data  []byte
	}
}

// Extract autogenerated method of DecoderOptionalsStress
func (p *DecoderOptionalsStress) Extract(line []byte) (bool, error) {
	var err error
	var headRest []byte
	var pos int
	var tmp []byte
	var tmpInt int64
	p.rest = line

	// Take until ' ' as Int8(int8)
	pos = bytes.IndexByte(p.rest, ' ')

	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Int8", ' ', p.rest)
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 8); err != nil {
		fmt.Errorf("error parsing `\033[1m%s\033]0m` value as int8 for field `\033[1mInt8\033[0m`: %s", tmp, err)
	}
	p.Int8 = int8(tmpInt)
	headRest = p.rest

	// Checks if the rest starts with `"head="` and pass it
	if bytes.HasPrefix(headRest, headEq) {
		headRest = headRest[len(headEq):]
	} else {
		goto headLabel
	}

	// Take until ' ' as Data(string)
	pos = bytes.IndexByte(headRest, ' ')

	if pos >= 0 {
		tmp = headRest[:pos]
		headRest = headRest[pos+1:]
	} else {
		p.Head.Valid = false
		goto headLabel
	}
	p.Head.Data = tmp
	p.Head.Valid = true
	p.Head.Valid = true
	p.rest = headRest

	// Checks if the rest starts with `"end"` and pass it
	if bytes.HasPrefix(p.rest, end) {
		p.rest = p.rest[len(end):]
	} else {
		return false, fmt.Errorf("`\033[1m%s\033[0m)` is expected to start with `\033[1m%s\033[0m`", p.rest, "end")
	}

	return true, nil
}

// GetHeadData retrieves optional value for HeadData.Name
func (p *DecoderOptionalsStress) GetHeadData() (res []byte) {
	if !p.Head.Valid {
		return
	}
	return p.Head.Data
}

// DecoderBranching autogenerated parser
type DecoderBranching struct {
	rest []byte
	Head struct {
		Valid bool
		Data  []byte
	}
}

// Extract autogenerated method of DecoderBranching
func (p *DecoderBranching) Extract(line []byte) (bool, error) {
	var headRest []byte
	var pos int
	var tmp []byte
	p.rest = line

	// Checks if the rest starts with `"start "` and pass it
	if bytes.HasPrefix(p.rest, startSpace) {
		p.rest = p.rest[len(startSpace):]
	}
	headRest = p.rest

	// Checks if the rest starts with `"head="` and pass it
	if bytes.HasPrefix(headRest, headEq) {
		headRest = headRest[len(headEq):]
	}

	// Take until ' ' (or all the rest if not found) as Data(string)
	pos = bytes.IndexByte(headRest, ' ')

	if pos >= 0 {
		tmp = headRest[:pos]
		headRest = headRest[pos+1:]
	} else {
		tmp = headRest
		headRest = headRest[len(headRest):]
	}
	p.Head.Data = tmp
	p.Head.Valid = true
	p.Head.Valid = true
	p.rest = headRest

	return true, nil
}

// GetHeadData retrieves optional value for HeadData.Name
func (p *DecoderBranching) GetHeadData() (res []byte) {
	if !p.Head.Valid {
		return
	}
	return p.Head.Data
}

// DecoderBranchingStress autogenerated parser
type DecoderBranchingStress struct {
	rest []byte
	Head struct {
		Valid bool
		Data  []byte
	}
}

// Extract autogenerated method of DecoderBranchingStress
func (p *DecoderBranchingStress) Extract(line []byte) (bool, error) {
	var headRest []byte
	var pos int
	var tmp []byte
	p.rest = line

	// Checks if the rest starts with `"start "` and pass it
	if bytes.HasPrefix(p.rest, startSpace) {
		p.rest = p.rest[len(startSpace):]
	}
	headRest = p.rest

	// Checks if the rest starts with `"head="` and pass it
	if bytes.HasPrefix(headRest, headEq) {
		headRest = headRest[len(headEq):]
	}

	// Take until ' ' (or all the rest if not found) as Data(string)
	pos = bytes.IndexByte(headRest, ' ')

	if pos >= 0 {
		tmp = headRest[:pos]
		headRest = headRest[pos+1:]
	} else {
		tmp = headRest
		headRest = headRest[len(headRest):]
	}
	p.Head.Data = tmp
	p.Head.Valid = true
	p.Head.Valid = true
	p.rest = headRest

	return true, nil
}

// GetHeadData retrieves optional value for HeadData.Name
func (p *DecoderBranchingStress) GetHeadData() (res []byte) {
	if !p.Head.Valid {
		return
	}
	return p.Head.Data
}

// DoubleOpts autogenerated parser
type DoubleOpts struct {
	rest []byte
	Head struct {
		Valid bool
		Data  []byte
	}
	Rest struct {
		Valid bool
		Data  []byte
	}
}

// Extract autogenerated method of DoubleOpts
func (p *DoubleOpts) Extract(line []byte) (bool, error) {
	var headRest []byte
	var pos int
	var restRest []byte
	var tmp []byte
	p.rest = line
	headRest = p.rest

	// Checks if the rest starts with `"head="` and pass it
	if bytes.HasPrefix(headRest, headEq) {
		headRest = headRest[len(headEq):]
	} else {
		goto headLabel
	}

	// Take until ' ' (or all the rest if not found) as Data(string)
	pos = bytes.IndexByte(headRest, ' ')

	if pos >= 0 {
		tmp = headRest[:pos]
		headRest = headRest[pos+1:]
	} else {
		tmp = headRest
		headRest = headRest[len(headRest):]
	}
	p.Head.Data = tmp
	p.Head.Valid = true
	p.Head.Valid = true
	p.rest = headRest

	restRest = p.rest

	// Checks if the rest starts with `"rest="` and pass it
	if bytes.HasPrefix(restRest, restEq) {
		restRest = restRest[len(restEq):]
	} else {
		goto restLabel
	}

	// Take until ' ' (or all the rest if not found) as Data(string)
	pos = bytes.IndexByte(restRest, ' ')

	if pos >= 0 {
		tmp = restRest[:pos]
		restRest = restRest[pos+1:]
	} else {
		tmp = restRest
		restRest = restRest[len(restRest):]
	}
	p.Rest.Data = tmp
	p.Rest.Valid = true
	p.Rest.Valid = true
	p.rest = restRest

	return true, nil
}

// GetHeadData retrieves optional value for HeadData.Name
func (p *DoubleOpts) GetHeadData() (res []byte) {
	if !p.Head.Valid {
		return
	}
	return p.Head.Data
}

// GetRestData retrieves optional value for RestData.Name
func (p *DoubleOpts) GetRestData() (res []byte) {
	if !p.Rest.Valid {
		return
	}
	return p.Rest.Data
}
