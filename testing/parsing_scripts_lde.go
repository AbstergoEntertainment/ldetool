/* This file was autogenerated via
-----------------------------------------
 ldetool generate --code-source ../generator/gogen/template_data --package ldetesting parsing.scripts
-----------------------------------------
do not touch it with bare hands!
*/

package ldetesting

import (
	"bytes"
	"fmt"
	"strconv"
	"unsafe"
)

var end = []byte("end")
var headEq = []byte("head=")
var space = []byte(" ")
var startSpace = []byte("start ")

// decoders autogenerated parser
type decoders struct {
	rest    []byte
	Int8    int8
	Int16   int16
	Int32   int32
	Int64   int64
	Uint8   uint8
	Uint16  uint16
	Uint32  uint32
	Uint64  uint64
	Float32 float32
	Float64 float64
	String  []byte
}

// decodersLimited autogenerated parser
type decodersLimited struct {
	rest    []byte
	Int8    int8
	Int16   int16
	Int32   int32
	Int64   int64
	Uint8   uint8
	Uint16  uint16
	Uint32  uint32
	Uint64  uint64
	Float32 float32
	Float64 float64
	String  []byte
}

// decodersBounded autogenerated parser
type decodersBounded struct {
	rest  []byte
	Int64 int64
}

// decodersString autogenerated parser
type decodersString struct {
	rest    []byte
	Int8    int8
	Int16   int16
	Int32   int32
	Int64   int64
	Uint8   uint8
	Uint16  uint16
	Uint32  uint32
	Uint64  uint64
	Float32 float32
	Float64 float64
	String  []byte
}

// decodersLimitedString autogenerated parser
type decodersLimitedString struct {
	rest    []byte
	Int8    int8
	Int16   int16
	Int32   int32
	Int64   int64
	Uint8   uint8
	Uint16  uint16
	Uint32  uint32
	Uint64  uint64
	Float32 float32
	Float64 float64
	String  []byte
}

// decodersBoundedString autogenerated parser
type decodersBoundedString struct {
	rest    []byte
	Float64 float64
}

// decodersStress autogenerated parser
type decodersStress struct {
	rest    []byte
	Int8    int8
	Int16   int16
	Int32   int32
	Int64   int64
	Uint8   uint8
	Uint16  uint16
	Uint32  uint32
	Uint64  uint64
	Float32 float32
	Float64 float64
	String  []byte
}

// decodersLimitedStress autogenerated parser
type decodersLimitedStress struct {
	rest    []byte
	Int8    int8
	Int16   int16
	Int32   int32
	Int64   int64
	Uint8   uint8
	Uint16  uint16
	Uint32  uint32
	Uint64  uint64
	Float32 float32
	Float64 float64
	String  []byte
}

// decodersBoundedStress autogenerated parser
type decodersBoundedStress struct {
	rest  []byte
	Int64 int64
}

// decodersStringStress autogenerated parser
type decodersStringStress struct {
	rest    []byte
	Int8    int8
	Int16   int16
	Int32   int32
	Int64   int64
	Uint8   uint8
	Uint16  uint16
	Uint32  uint32
	Uint64  uint64
	Float32 float32
	Float64 float64
	String  []byte
}

// decodersLimitedStringStress autogenerated parser
type decodersLimitedStringStress struct {
	rest    []byte
	Int8    int8
	Int16   int16
	Int32   int32
	Int64   int64
	Uint8   uint8
	Uint16  uint16
	Uint32  uint32
	Uint64  uint64
	Float32 float32
	Float64 float64
	String  []byte
}

// decodersBoundedStringStress autogenerated parser
type decodersBoundedStringStress struct {
	rest    []byte
	Float64 float64
}

// decoderOptionals autogenerated parser
type decoderOptionals struct {
	rest []byte
	Int8 int8
	Head struct {
		Valid bool
		Data  []byte
	}
}

// decoderOptionalsStress autogenerated parser
type decoderOptionalsStress struct {
	rest []byte
	Int8 int8
	Head struct {
		Valid bool
		Data  []byte
	}
}

// decoderBranching autogenerated parser
type decoderBranching struct {
	rest []byte
	Head struct {
		Valid bool
		Data  []byte
	}
}

// decoderBranchingStress autogenerated parser
type decoderBranchingStress struct {
	rest []byte
	Head struct {
		Valid bool
		Data  []byte
	}
}

// Parse autogenerated method of decoders
func (p *decoders) Parse(line []byte) (bool, error) {
	var err error
	var pos int
	var tmp []byte
	var tmpFloat float64
	var tmpInt int64
	var tmpUint uint64
	p.rest = line

	// Put data before ' ' into Int8
	if pos = bytes.IndexByte(p.rest, ' '); pos >= 0 {
		tmp = p.rest[:pos]
		if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 8); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as int8 for field \033[1mInt8\033[0m: %s", string(tmp), err)
		}
		p.Int8 = int8(tmpInt)
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	// Put data before ' ' into Int16
	if pos = bytes.IndexByte(p.rest, ' '); pos >= 0 {
		tmp = p.rest[:pos]
		if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 16); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as int16 for field \033[1mInt16\033[0m: %s", string(tmp), err)
		}
		p.Int16 = int16(tmpInt)
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	// Put data before ' ' into Int32
	if pos = bytes.IndexByte(p.rest, ' '); pos >= 0 {
		tmp = p.rest[:pos]
		if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as int32 for field \033[1mInt32\033[0m: %s", string(tmp), err)
		}
		p.Int32 = int32(tmpInt)
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	// Put data before ' ' into Int64
	if pos = bytes.IndexByte(p.rest, ' '); pos >= 0 {
		tmp = p.rest[:pos]
		if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as int64 for field \033[1mInt64\033[0m: %s", string(tmp), err)
		}
		p.Int64 = int64(tmpInt)
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	// Put data before ' ' into Uint8
	if pos = bytes.IndexByte(p.rest, ' '); pos >= 0 {
		tmp = p.rest[:pos]
		if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 8); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as uint8 for field \033[1mUint8\033[0m: %s", string(tmp), err)
		}
		p.Uint8 = uint8(tmpUint)
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	// Put data before ' ' into Uint16
	if pos = bytes.IndexByte(p.rest, ' '); pos >= 0 {
		tmp = p.rest[:pos]
		if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 16); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as uint16 for field \033[1mUint16\033[0m: %s", string(tmp), err)
		}
		p.Uint16 = uint16(tmpUint)
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	// Put data before ' ' into Uint32
	if pos = bytes.IndexByte(p.rest, ' '); pos >= 0 {
		tmp = p.rest[:pos]
		if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as uint32 for field \033[1mUint32\033[0m: %s", string(tmp), err)
		}
		p.Uint32 = uint32(tmpUint)
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	// Put data before ' ' into Uint64
	if pos = bytes.IndexByte(p.rest, ' '); pos >= 0 {
		tmp = p.rest[:pos]
		if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as uint64 for field \033[1mUint64\033[0m: %s", string(tmp), err)
		}
		p.Uint64 = uint64(tmpUint)
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	// Put data before ' ' into Float32
	if pos = bytes.IndexByte(p.rest, ' '); pos >= 0 {
		tmp = p.rest[:pos]
		if tmpFloat, err = strconv.ParseFloat(*(*string)(unsafe.Pointer(&tmp)), 32); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as float32 for field \033[1mFloat32\033[0m: %s", string(tmp), err)
		}
		p.Float32 = float32(tmpFloat)
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	// Put data before ' ' into Float64
	if pos = bytes.IndexByte(p.rest, ' '); pos >= 0 {
		tmp = p.rest[:pos]
		if tmpFloat, err = strconv.ParseFloat(*(*string)(unsafe.Pointer(&tmp)), 64); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as float64 for field \033[1mFloat64\033[0m: %s", string(tmp), err)
		}
		p.Float64 = float64(tmpFloat)
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	// Put data before ' ' into String
	if pos = bytes.IndexByte(p.rest, ' '); pos >= 0 {
		p.String = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	return true, nil
}

// Parse autogenerated method of decodersLimited
func (p *decodersLimited) Parse(line []byte) (bool, error) {
	var err error
	var pos int
	var tmp []byte
	var tmpFloat float64
	var tmpInt int64
	var tmpUint uint64
	p.rest = line

	// Put data before ' ' into Int8 with limited to 8 symbols boundary lookup
	if len(p.rest) < 8 {
		return false, nil
	}
	if pos = bytes.IndexByte(p.rest[:8], ' '); pos >= 0 {
		tmp = p.rest[:pos]
		if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 8); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as int8 for field \033[1mInt8\033[0m: %s", string(tmp), err)
		}
		p.Int8 = int8(tmpInt)
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	// Put data before ' ' into Int16 with limited to 8 symbols boundary lookup
	if len(p.rest) < 8 {
		return false, nil
	}
	if pos = bytes.IndexByte(p.rest[:8], ' '); pos >= 0 {
		tmp = p.rest[:pos]
		if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 16); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as int16 for field \033[1mInt16\033[0m: %s", string(tmp), err)
		}
		p.Int16 = int16(tmpInt)
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	// Put data before ' ' into Int32 with limited to 8 symbols boundary lookup
	if len(p.rest) < 8 {
		return false, nil
	}
	if pos = bytes.IndexByte(p.rest[:8], ' '); pos >= 0 {
		tmp = p.rest[:pos]
		if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as int32 for field \033[1mInt32\033[0m: %s", string(tmp), err)
		}
		p.Int32 = int32(tmpInt)
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	// Put data before ' ' into Int64 with limited to 8 symbols boundary lookup
	if len(p.rest) < 8 {
		return false, nil
	}
	if pos = bytes.IndexByte(p.rest[:8], ' '); pos >= 0 {
		tmp = p.rest[:pos]
		if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as int64 for field \033[1mInt64\033[0m: %s", string(tmp), err)
		}
		p.Int64 = int64(tmpInt)
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	// Put data before ' ' into Uint8 with limited to 8 symbols boundary lookup
	if len(p.rest) < 8 {
		return false, nil
	}
	if pos = bytes.IndexByte(p.rest[:8], ' '); pos >= 0 {
		tmp = p.rest[:pos]
		if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 8); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as uint8 for field \033[1mUint8\033[0m: %s", string(tmp), err)
		}
		p.Uint8 = uint8(tmpUint)
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	// Put data before ' ' into Uint16 with limited to 8 symbols boundary lookup
	if len(p.rest) < 8 {
		return false, nil
	}
	if pos = bytes.IndexByte(p.rest[:8], ' '); pos >= 0 {
		tmp = p.rest[:pos]
		if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 16); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as uint16 for field \033[1mUint16\033[0m: %s", string(tmp), err)
		}
		p.Uint16 = uint16(tmpUint)
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	// Put data before ' ' into Uint32 with limited to 8 symbols boundary lookup
	if len(p.rest) < 8 {
		return false, nil
	}
	if pos = bytes.IndexByte(p.rest[:8], ' '); pos >= 0 {
		tmp = p.rest[:pos]
		if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as uint32 for field \033[1mUint32\033[0m: %s", string(tmp), err)
		}
		p.Uint32 = uint32(tmpUint)
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	// Put data before ' ' into Uint64 with limited to 8 symbols boundary lookup
	if len(p.rest) < 8 {
		return false, nil
	}
	if pos = bytes.IndexByte(p.rest[:8], ' '); pos >= 0 {
		tmp = p.rest[:pos]
		if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as uint64 for field \033[1mUint64\033[0m: %s", string(tmp), err)
		}
		p.Uint64 = uint64(tmpUint)
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	// Put data before ' ' into Float32 with limited to 8 symbols boundary lookup
	if len(p.rest) < 8 {
		return false, nil
	}
	if pos = bytes.IndexByte(p.rest[:8], ' '); pos >= 0 {
		tmp = p.rest[:pos]
		if tmpFloat, err = strconv.ParseFloat(*(*string)(unsafe.Pointer(&tmp)), 32); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as float32 for field \033[1mFloat32\033[0m: %s", string(tmp), err)
		}
		p.Float32 = float32(tmpFloat)
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	// Put data before ' ' into Float64 with limited to 8 symbols boundary lookup
	if len(p.rest) < 8 {
		return false, nil
	}
	if pos = bytes.IndexByte(p.rest[:8], ' '); pos >= 0 {
		tmp = p.rest[:pos]
		if tmpFloat, err = strconv.ParseFloat(*(*string)(unsafe.Pointer(&tmp)), 64); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as float64 for field \033[1mFloat64\033[0m: %s", string(tmp), err)
		}
		p.Float64 = float64(tmpFloat)
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	// Put data before ' ' into String with limited to 8 symbols boundary lookup
	if len(p.rest) < 8 {
		return false, nil
	}
	if pos = bytes.IndexByte(p.rest[:8], ' '); pos >= 0 {
		p.String = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	return true, nil
}

// Parse autogenerated method of decodersBounded
func (p *decodersBounded) Parse(line []byte) (bool, error) {
	var err error
	var pos int
	var tmp []byte
	var tmpInt int64
	p.rest = line

	// Put data before ' ' into Int64 with limited to 8..16 symbol range boundary lookup
	if len(p.rest) < 16 {
		return false, nil
	}
	if pos = bytes.IndexByte(p.rest[8:16], ' '); pos >= 0 {
		tmp = p.rest[:8+pos]
		if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as int64 for field \033[1mInt64\033[0m: %s", string(tmp), err)
		}
		p.Int64 = int64(tmpInt)
		p.rest = p.rest[pos+8+1:]
	} else {
		return false, nil
	}
	return true, nil
}

// Parse autogenerated method of decodersString
func (p *decodersString) Parse(line []byte) (bool, error) {
	var err error
	var pos int
	var tmp []byte
	var tmpFloat float64
	var tmpInt int64
	var tmpUint uint64
	p.rest = line

	// Put data before " " into Int8
	if pos = bytes.Index(p.rest, space); pos >= 0 {
		tmp = p.rest[:pos]
		if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 8); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as int8 for field \033[1mInt8\033[0m: %s", string(tmp), err)
		}
		p.Int8 = int8(tmpInt)
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}
	// Put data before " " into Int16
	if pos = bytes.Index(p.rest, space); pos >= 0 {
		tmp = p.rest[:pos]
		if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 16); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as int16 for field \033[1mInt16\033[0m: %s", string(tmp), err)
		}
		p.Int16 = int16(tmpInt)
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}
	// Put data before " " into Int32
	if pos = bytes.Index(p.rest, space); pos >= 0 {
		tmp = p.rest[:pos]
		if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as int32 for field \033[1mInt32\033[0m: %s", string(tmp), err)
		}
		p.Int32 = int32(tmpInt)
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}
	// Put data before " " into Int64
	if pos = bytes.Index(p.rest, space); pos >= 0 {
		tmp = p.rest[:pos]
		if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as int64 for field \033[1mInt64\033[0m: %s", string(tmp), err)
		}
		p.Int64 = int64(tmpInt)
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}
	// Put data before " " into Uint8
	if pos = bytes.Index(p.rest, space); pos >= 0 {
		tmp = p.rest[:pos]
		if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 8); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as uint8 for field \033[1mUint8\033[0m: %s", string(tmp), err)
		}
		p.Uint8 = uint8(tmpUint)
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}
	// Put data before " " into Uint16
	if pos = bytes.Index(p.rest, space); pos >= 0 {
		tmp = p.rest[:pos]
		if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 16); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as uint16 for field \033[1mUint16\033[0m: %s", string(tmp), err)
		}
		p.Uint16 = uint16(tmpUint)
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}
	// Put data before " " into Uint32
	if pos = bytes.Index(p.rest, space); pos >= 0 {
		tmp = p.rest[:pos]
		if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as uint32 for field \033[1mUint32\033[0m: %s", string(tmp), err)
		}
		p.Uint32 = uint32(tmpUint)
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}
	// Put data before " " into Uint64
	if pos = bytes.Index(p.rest, space); pos >= 0 {
		tmp = p.rest[:pos]
		if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as uint64 for field \033[1mUint64\033[0m: %s", string(tmp), err)
		}
		p.Uint64 = uint64(tmpUint)
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}
	// Put data before " " into Float32
	if pos = bytes.Index(p.rest, space); pos >= 0 {
		tmp = p.rest[:pos]
		if tmpFloat, err = strconv.ParseFloat(*(*string)(unsafe.Pointer(&tmp)), 32); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as float32 for field \033[1mFloat32\033[0m: %s", string(tmp), err)
		}
		p.Float32 = float32(tmpFloat)
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}
	// Put data before " " into Float64
	if pos = bytes.Index(p.rest, space); pos >= 0 {
		tmp = p.rest[:pos]
		if tmpFloat, err = strconv.ParseFloat(*(*string)(unsafe.Pointer(&tmp)), 64); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as float64 for field \033[1mFloat64\033[0m: %s", string(tmp), err)
		}
		p.Float64 = float64(tmpFloat)
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}
	// Put data before " " into String
	if pos = bytes.Index(p.rest, space); pos >= 0 {
		p.String = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}
	return true, nil
}

// Parse autogenerated method of decodersLimitedString
func (p *decodersLimitedString) Parse(line []byte) (bool, error) {
	var err error
	var pos int
	var tmp []byte
	var tmpFloat float64
	var tmpInt int64
	var tmpUint uint64
	p.rest = line

	// Put data before " " into Int8 with limited to 8 symbols boundary lookup
	if len(p.rest) < 8 {
		return false, nil
	}
	if pos = bytes.Index(p.rest[:8], space); pos >= 0 {
		tmp = p.rest[:pos]
		if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 8); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as int8 for field \033[1mInt8\033[0m: %s", string(tmp), err)
		}
		p.Int8 = int8(tmpInt)
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}
	// Put data before " " into Int16 with limited to 8 symbols boundary lookup
	if len(p.rest) < 8 {
		return false, nil
	}
	if pos = bytes.Index(p.rest[:8], space); pos >= 0 {
		tmp = p.rest[:pos]
		if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 16); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as int16 for field \033[1mInt16\033[0m: %s", string(tmp), err)
		}
		p.Int16 = int16(tmpInt)
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}
	// Put data before " " into Int32 with limited to 8 symbols boundary lookup
	if len(p.rest) < 8 {
		return false, nil
	}
	if pos = bytes.Index(p.rest[:8], space); pos >= 0 {
		tmp = p.rest[:pos]
		if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as int32 for field \033[1mInt32\033[0m: %s", string(tmp), err)
		}
		p.Int32 = int32(tmpInt)
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}
	// Put data before " " into Int64 with limited to 8 symbols boundary lookup
	if len(p.rest) < 8 {
		return false, nil
	}
	if pos = bytes.Index(p.rest[:8], space); pos >= 0 {
		tmp = p.rest[:pos]
		if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as int64 for field \033[1mInt64\033[0m: %s", string(tmp), err)
		}
		p.Int64 = int64(tmpInt)
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}
	// Put data before " " into Uint8 with limited to 8 symbols boundary lookup
	if len(p.rest) < 8 {
		return false, nil
	}
	if pos = bytes.Index(p.rest[:8], space); pos >= 0 {
		tmp = p.rest[:pos]
		if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 8); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as uint8 for field \033[1mUint8\033[0m: %s", string(tmp), err)
		}
		p.Uint8 = uint8(tmpUint)
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}
	// Put data before " " into Uint16 with limited to 8 symbols boundary lookup
	if len(p.rest) < 8 {
		return false, nil
	}
	if pos = bytes.Index(p.rest[:8], space); pos >= 0 {
		tmp = p.rest[:pos]
		if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 16); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as uint16 for field \033[1mUint16\033[0m: %s", string(tmp), err)
		}
		p.Uint16 = uint16(tmpUint)
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}
	// Put data before " " into Uint32 with limited to 8 symbols boundary lookup
	if len(p.rest) < 8 {
		return false, nil
	}
	if pos = bytes.Index(p.rest[:8], space); pos >= 0 {
		tmp = p.rest[:pos]
		if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as uint32 for field \033[1mUint32\033[0m: %s", string(tmp), err)
		}
		p.Uint32 = uint32(tmpUint)
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}
	// Put data before " " into Uint64 with limited to 8 symbols boundary lookup
	if len(p.rest) < 8 {
		return false, nil
	}
	if pos = bytes.Index(p.rest[:8], space); pos >= 0 {
		tmp = p.rest[:pos]
		if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as uint64 for field \033[1mUint64\033[0m: %s", string(tmp), err)
		}
		p.Uint64 = uint64(tmpUint)
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}
	// Put data before " " into Float32 with limited to 8 symbols boundary lookup
	if len(p.rest) < 8 {
		return false, nil
	}
	if pos = bytes.Index(p.rest[:8], space); pos >= 0 {
		tmp = p.rest[:pos]
		if tmpFloat, err = strconv.ParseFloat(*(*string)(unsafe.Pointer(&tmp)), 32); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as float32 for field \033[1mFloat32\033[0m: %s", string(tmp), err)
		}
		p.Float32 = float32(tmpFloat)
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}
	// Put data before " " into Float64 with limited to 8 symbols boundary lookup
	if len(p.rest) < 8 {
		return false, nil
	}
	if pos = bytes.Index(p.rest[:8], space); pos >= 0 {
		tmp = p.rest[:pos]
		if tmpFloat, err = strconv.ParseFloat(*(*string)(unsafe.Pointer(&tmp)), 64); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as float64 for field \033[1mFloat64\033[0m: %s", string(tmp), err)
		}
		p.Float64 = float64(tmpFloat)
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}
	// Put data before " " into String with limited to 8 symbols boundary lookup
	if len(p.rest) < 8 {
		return false, nil
	}
	if pos = bytes.Index(p.rest[:8], space); pos >= 0 {
		p.String = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}
	return true, nil
}

// Parse autogenerated method of decodersBoundedString
func (p *decodersBoundedString) Parse(line []byte) (bool, error) {
	var err error
	var pos int
	var tmp []byte
	var tmpFloat float64
	p.rest = line

	// Put data before " " into Float64 with limited to 8..16 symbol range boundary lookup
	if len(p.rest) < 16 {
		return false, nil
	}
	if pos = bytes.Index(p.rest[8:16], space); pos >= 0 {
		tmp = p.rest[:8+pos]
		if tmpFloat, err = strconv.ParseFloat(*(*string)(unsafe.Pointer(&tmp)), 64); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as float64 for field \033[1mFloat64\033[0m: %s", string(tmp), err)
		}
		p.Float64 = float64(tmpFloat)
		p.rest = p.rest[pos+8+len(space):]
	} else {
		return false, nil
	}
	return true, nil
}

// Parse autogenerated method of decodersStress
func (p *decodersStress) Parse(line []byte) (bool, error) {
	var err error
	var pos int
	var tmp []byte
	var tmpFloat float64
	var tmpInt int64
	var tmpUint uint64
	p.rest = line

	// Put data before ' ' into Int8
	if pos = bytes.IndexByte(p.rest, ' '); pos >= 0 {
		tmp = p.rest[:pos]
		if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 8); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as int8 for field \033[1mInt8\033[0m: %s", string(tmp), err)
		}
		p.Int8 = int8(tmpInt)
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Int8", ' ', string(p.rest))
	}
	// Put data before ' ' into Int16
	if pos = bytes.IndexByte(p.rest, ' '); pos >= 0 {
		tmp = p.rest[:pos]
		if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 16); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as int16 for field \033[1mInt16\033[0m: %s", string(tmp), err)
		}
		p.Int16 = int16(tmpInt)
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Int16", ' ', string(p.rest))
	}
	// Put data before ' ' into Int32
	if pos = bytes.IndexByte(p.rest, ' '); pos >= 0 {
		tmp = p.rest[:pos]
		if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as int32 for field \033[1mInt32\033[0m: %s", string(tmp), err)
		}
		p.Int32 = int32(tmpInt)
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Int32", ' ', string(p.rest))
	}
	// Put data before ' ' into Int64
	if pos = bytes.IndexByte(p.rest, ' '); pos >= 0 {
		tmp = p.rest[:pos]
		if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as int64 for field \033[1mInt64\033[0m: %s", string(tmp), err)
		}
		p.Int64 = int64(tmpInt)
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Int64", ' ', string(p.rest))
	}
	// Put data before ' ' into Uint8
	if pos = bytes.IndexByte(p.rest, ' '); pos >= 0 {
		tmp = p.rest[:pos]
		if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 8); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as uint8 for field \033[1mUint8\033[0m: %s", string(tmp), err)
		}
		p.Uint8 = uint8(tmpUint)
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint8", ' ', string(p.rest))
	}
	// Put data before ' ' into Uint16
	if pos = bytes.IndexByte(p.rest, ' '); pos >= 0 {
		tmp = p.rest[:pos]
		if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 16); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as uint16 for field \033[1mUint16\033[0m: %s", string(tmp), err)
		}
		p.Uint16 = uint16(tmpUint)
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint16", ' ', string(p.rest))
	}
	// Put data before ' ' into Uint32
	if pos = bytes.IndexByte(p.rest, ' '); pos >= 0 {
		tmp = p.rest[:pos]
		if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as uint32 for field \033[1mUint32\033[0m: %s", string(tmp), err)
		}
		p.Uint32 = uint32(tmpUint)
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint32", ' ', string(p.rest))
	}
	// Put data before ' ' into Uint64
	if pos = bytes.IndexByte(p.rest, ' '); pos >= 0 {
		tmp = p.rest[:pos]
		if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as uint64 for field \033[1mUint64\033[0m: %s", string(tmp), err)
		}
		p.Uint64 = uint64(tmpUint)
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint64", ' ', string(p.rest))
	}
	// Put data before ' ' into Float32
	if pos = bytes.IndexByte(p.rest, ' '); pos >= 0 {
		tmp = p.rest[:pos]
		if tmpFloat, err = strconv.ParseFloat(*(*string)(unsafe.Pointer(&tmp)), 32); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as float32 for field \033[1mFloat32\033[0m: %s", string(tmp), err)
		}
		p.Float32 = float32(tmpFloat)
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Float32", ' ', string(p.rest))
	}
	// Put data before ' ' into Float64
	if pos = bytes.IndexByte(p.rest, ' '); pos >= 0 {
		tmp = p.rest[:pos]
		if tmpFloat, err = strconv.ParseFloat(*(*string)(unsafe.Pointer(&tmp)), 64); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as float64 for field \033[1mFloat64\033[0m: %s", string(tmp), err)
		}
		p.Float64 = float64(tmpFloat)
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Float64", ' ', string(p.rest))
	}
	// Put data before ' ' into String
	if pos = bytes.IndexByte(p.rest, ' '); pos >= 0 {
		p.String = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field String", ' ', string(p.rest))
	}
	return true, nil
}

// Parse autogenerated method of decodersLimitedStress
func (p *decodersLimitedStress) Parse(line []byte) (bool, error) {
	var err error
	var pos int
	var tmp []byte
	var tmpFloat float64
	var tmpInt int64
	var tmpUint uint64
	p.rest = line

	// Put data before ' ' into Int8 with limited to 8 symbols boundary lookup
	if len(p.rest) < 8 {
		return false, fmt.Errorf("Requested lookup in first 8 symbols to bound value for Int8 of the rest while only %d left", len(p.rest))
	}
	if pos = bytes.IndexByte(p.rest[:8], ' '); pos >= 0 {
		tmp = p.rest[:pos]
		if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 8); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as int8 for field \033[1mInt8\033[0m: %s", string(tmp), err)
		}
		p.Int8 = int8(tmpInt)
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Int8", ' ', string(p.rest[:8]))
	}
	// Put data before ' ' into Int16 with limited to 8 symbols boundary lookup
	if len(p.rest) < 8 {
		return false, fmt.Errorf("Requested lookup in first 8 symbols to bound value for Int16 of the rest while only %d left", len(p.rest))
	}
	if pos = bytes.IndexByte(p.rest[:8], ' '); pos >= 0 {
		tmp = p.rest[:pos]
		if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 16); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as int16 for field \033[1mInt16\033[0m: %s", string(tmp), err)
		}
		p.Int16 = int16(tmpInt)
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Int16", ' ', string(p.rest[:8]))
	}
	// Put data before ' ' into Int32 with limited to 8 symbols boundary lookup
	if len(p.rest) < 8 {
		return false, fmt.Errorf("Requested lookup in first 8 symbols to bound value for Int32 of the rest while only %d left", len(p.rest))
	}
	if pos = bytes.IndexByte(p.rest[:8], ' '); pos >= 0 {
		tmp = p.rest[:pos]
		if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as int32 for field \033[1mInt32\033[0m: %s", string(tmp), err)
		}
		p.Int32 = int32(tmpInt)
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Int32", ' ', string(p.rest[:8]))
	}
	// Put data before ' ' into Int64 with limited to 8 symbols boundary lookup
	if len(p.rest) < 8 {
		return false, fmt.Errorf("Requested lookup in first 8 symbols to bound value for Int64 of the rest while only %d left", len(p.rest))
	}
	if pos = bytes.IndexByte(p.rest[:8], ' '); pos >= 0 {
		tmp = p.rest[:pos]
		if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as int64 for field \033[1mInt64\033[0m: %s", string(tmp), err)
		}
		p.Int64 = int64(tmpInt)
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Int64", ' ', string(p.rest[:8]))
	}
	// Put data before ' ' into Uint8 with limited to 8 symbols boundary lookup
	if len(p.rest) < 8 {
		return false, fmt.Errorf("Requested lookup in first 8 symbols to bound value for Uint8 of the rest while only %d left", len(p.rest))
	}
	if pos = bytes.IndexByte(p.rest[:8], ' '); pos >= 0 {
		tmp = p.rest[:pos]
		if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 8); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as uint8 for field \033[1mUint8\033[0m: %s", string(tmp), err)
		}
		p.Uint8 = uint8(tmpUint)
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint8", ' ', string(p.rest[:8]))
	}
	// Put data before ' ' into Uint16 with limited to 8 symbols boundary lookup
	if len(p.rest) < 8 {
		return false, fmt.Errorf("Requested lookup in first 8 symbols to bound value for Uint16 of the rest while only %d left", len(p.rest))
	}
	if pos = bytes.IndexByte(p.rest[:8], ' '); pos >= 0 {
		tmp = p.rest[:pos]
		if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 16); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as uint16 for field \033[1mUint16\033[0m: %s", string(tmp), err)
		}
		p.Uint16 = uint16(tmpUint)
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint16", ' ', string(p.rest[:8]))
	}
	// Put data before ' ' into Uint32 with limited to 8 symbols boundary lookup
	if len(p.rest) < 8 {
		return false, fmt.Errorf("Requested lookup in first 8 symbols to bound value for Uint32 of the rest while only %d left", len(p.rest))
	}
	if pos = bytes.IndexByte(p.rest[:8], ' '); pos >= 0 {
		tmp = p.rest[:pos]
		if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as uint32 for field \033[1mUint32\033[0m: %s", string(tmp), err)
		}
		p.Uint32 = uint32(tmpUint)
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint32", ' ', string(p.rest[:8]))
	}
	// Put data before ' ' into Uint64 with limited to 8 symbols boundary lookup
	if len(p.rest) < 8 {
		return false, fmt.Errorf("Requested lookup in first 8 symbols to bound value for Uint64 of the rest while only %d left", len(p.rest))
	}
	if pos = bytes.IndexByte(p.rest[:8], ' '); pos >= 0 {
		tmp = p.rest[:pos]
		if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as uint64 for field \033[1mUint64\033[0m: %s", string(tmp), err)
		}
		p.Uint64 = uint64(tmpUint)
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint64", ' ', string(p.rest[:8]))
	}
	// Put data before ' ' into Float32 with limited to 8 symbols boundary lookup
	if len(p.rest) < 8 {
		return false, fmt.Errorf("Requested lookup in first 8 symbols to bound value for Float32 of the rest while only %d left", len(p.rest))
	}
	if pos = bytes.IndexByte(p.rest[:8], ' '); pos >= 0 {
		tmp = p.rest[:pos]
		if tmpFloat, err = strconv.ParseFloat(*(*string)(unsafe.Pointer(&tmp)), 32); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as float32 for field \033[1mFloat32\033[0m: %s", string(tmp), err)
		}
		p.Float32 = float32(tmpFloat)
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Float32", ' ', string(p.rest[:8]))
	}
	// Put data before ' ' into Float64 with limited to 8 symbols boundary lookup
	if len(p.rest) < 8 {
		return false, fmt.Errorf("Requested lookup in first 8 symbols to bound value for Float64 of the rest while only %d left", len(p.rest))
	}
	if pos = bytes.IndexByte(p.rest[:8], ' '); pos >= 0 {
		tmp = p.rest[:pos]
		if tmpFloat, err = strconv.ParseFloat(*(*string)(unsafe.Pointer(&tmp)), 64); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as float64 for field \033[1mFloat64\033[0m: %s", string(tmp), err)
		}
		p.Float64 = float64(tmpFloat)
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Float64", ' ', string(p.rest[:8]))
	}
	// Put data before ' ' into String with limited to 8 symbols boundary lookup
	if len(p.rest) < 8 {
		return false, fmt.Errorf("Requested lookup in first 8 symbols to bound value for String of the rest while only %d left", len(p.rest))
	}
	if pos = bytes.IndexByte(p.rest[:8], ' '); pos >= 0 {
		p.String = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field String", ' ', string(p.rest[:8]))
	}
	return true, nil
}

// Parse autogenerated method of decodersBoundedStress
func (p *decodersBoundedStress) Parse(line []byte) (bool, error) {
	var err error
	var pos int
	var tmp []byte
	var tmpInt int64
	p.rest = line

	// Put data before ' ' into Int64 with limited to 8..16 symbol range boundary lookup
	if len(p.rest) < 16 {
		return false, fmt.Errorf("Requested lookup in first 16 symbols to bound value for Int64 of the rest while only %d left", len(p.rest))
	}
	if pos = bytes.IndexByte(p.rest[8:16], ' '); pos >= 0 {
		tmp = p.rest[:8+pos]
		if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as int64 for field \033[1mInt64\033[0m: %s", string(tmp), err)
		}
		p.Int64 = int64(tmpInt)
		p.rest = p.rest[pos+8+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Int64", ' ', string(p.rest[8:16]))
	}
	return true, nil
}

// Parse autogenerated method of decodersStringStress
func (p *decodersStringStress) Parse(line []byte) (bool, error) {
	var err error
	var pos int
	var tmp []byte
	var tmpFloat float64
	var tmpInt int64
	var tmpUint uint64
	p.rest = line

	// Put data before " " into Int8
	if pos = bytes.Index(p.rest, space); pos >= 0 {
		tmp = p.rest[:pos]
		if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 8); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as int8 for field \033[1mInt8\033[0m: %s", string(tmp), err)
		}
		p.Int8 = int8(tmpInt)
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Int8", space, string(p.rest))
	}
	// Put data before " " into Int16
	if pos = bytes.Index(p.rest, space); pos >= 0 {
		tmp = p.rest[:pos]
		if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 16); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as int16 for field \033[1mInt16\033[0m: %s", string(tmp), err)
		}
		p.Int16 = int16(tmpInt)
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Int16", space, string(p.rest))
	}
	// Put data before " " into Int32
	if pos = bytes.Index(p.rest, space); pos >= 0 {
		tmp = p.rest[:pos]
		if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as int32 for field \033[1mInt32\033[0m: %s", string(tmp), err)
		}
		p.Int32 = int32(tmpInt)
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Int32", space, string(p.rest))
	}
	// Put data before " " into Int64
	if pos = bytes.Index(p.rest, space); pos >= 0 {
		tmp = p.rest[:pos]
		if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as int64 for field \033[1mInt64\033[0m: %s", string(tmp), err)
		}
		p.Int64 = int64(tmpInt)
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Int64", space, string(p.rest))
	}
	// Put data before " " into Uint8
	if pos = bytes.Index(p.rest, space); pos >= 0 {
		tmp = p.rest[:pos]
		if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 8); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as uint8 for field \033[1mUint8\033[0m: %s", string(tmp), err)
		}
		p.Uint8 = uint8(tmpUint)
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint8", space, string(p.rest))
	}
	// Put data before " " into Uint16
	if pos = bytes.Index(p.rest, space); pos >= 0 {
		tmp = p.rest[:pos]
		if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 16); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as uint16 for field \033[1mUint16\033[0m: %s", string(tmp), err)
		}
		p.Uint16 = uint16(tmpUint)
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint16", space, string(p.rest))
	}
	// Put data before " " into Uint32
	if pos = bytes.Index(p.rest, space); pos >= 0 {
		tmp = p.rest[:pos]
		if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as uint32 for field \033[1mUint32\033[0m: %s", string(tmp), err)
		}
		p.Uint32 = uint32(tmpUint)
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint32", space, string(p.rest))
	}
	// Put data before " " into Uint64
	if pos = bytes.Index(p.rest, space); pos >= 0 {
		tmp = p.rest[:pos]
		if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as uint64 for field \033[1mUint64\033[0m: %s", string(tmp), err)
		}
		p.Uint64 = uint64(tmpUint)
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint64", space, string(p.rest))
	}
	// Put data before " " into Float32
	if pos = bytes.Index(p.rest, space); pos >= 0 {
		tmp = p.rest[:pos]
		if tmpFloat, err = strconv.ParseFloat(*(*string)(unsafe.Pointer(&tmp)), 32); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as float32 for field \033[1mFloat32\033[0m: %s", string(tmp), err)
		}
		p.Float32 = float32(tmpFloat)
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Float32", space, string(p.rest))
	}
	// Put data before " " into Float64
	if pos = bytes.Index(p.rest, space); pos >= 0 {
		tmp = p.rest[:pos]
		if tmpFloat, err = strconv.ParseFloat(*(*string)(unsafe.Pointer(&tmp)), 64); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as float64 for field \033[1mFloat64\033[0m: %s", string(tmp), err)
		}
		p.Float64 = float64(tmpFloat)
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Float64", space, string(p.rest))
	}
	// Put data before " " into String
	if pos = bytes.Index(p.rest, space); pos >= 0 {
		p.String = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field String", space, string(p.rest))
	}
	return true, nil
}

// Parse autogenerated method of decodersLimitedStringStress
func (p *decodersLimitedStringStress) Parse(line []byte) (bool, error) {
	var err error
	var pos int
	var tmp []byte
	var tmpFloat float64
	var tmpInt int64
	var tmpUint uint64
	p.rest = line

	// Put data before " " into Int8 with limited to 8 symbols boundary lookup
	if len(p.rest) < 8 {
		return false, fmt.Errorf("Requested lookup in first 8 symbols to bound value for Int8 of the rest while only %d left", len(p.rest))
	}
	if pos = bytes.Index(p.rest[:8], space); pos >= 0 {
		tmp = p.rest[:pos]
		if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 8); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as int8 for field \033[1mInt8\033[0m: %s", string(tmp), err)
		}
		p.Int8 = int8(tmpInt)
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Int8", space, string(p.rest[:8]))
	}
	// Put data before " " into Int16 with limited to 8 symbols boundary lookup
	if len(p.rest) < 8 {
		return false, fmt.Errorf("Requested lookup in first 8 symbols to bound value for Int16 of the rest while only %d left", len(p.rest))
	}
	if pos = bytes.Index(p.rest[:8], space); pos >= 0 {
		tmp = p.rest[:pos]
		if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 16); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as int16 for field \033[1mInt16\033[0m: %s", string(tmp), err)
		}
		p.Int16 = int16(tmpInt)
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Int16", space, string(p.rest[:8]))
	}
	// Put data before " " into Int32 with limited to 8 symbols boundary lookup
	if len(p.rest) < 8 {
		return false, fmt.Errorf("Requested lookup in first 8 symbols to bound value for Int32 of the rest while only %d left", len(p.rest))
	}
	if pos = bytes.Index(p.rest[:8], space); pos >= 0 {
		tmp = p.rest[:pos]
		if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as int32 for field \033[1mInt32\033[0m: %s", string(tmp), err)
		}
		p.Int32 = int32(tmpInt)
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Int32", space, string(p.rest[:8]))
	}
	// Put data before " " into Int64 with limited to 8 symbols boundary lookup
	if len(p.rest) < 8 {
		return false, fmt.Errorf("Requested lookup in first 8 symbols to bound value for Int64 of the rest while only %d left", len(p.rest))
	}
	if pos = bytes.Index(p.rest[:8], space); pos >= 0 {
		tmp = p.rest[:pos]
		if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as int64 for field \033[1mInt64\033[0m: %s", string(tmp), err)
		}
		p.Int64 = int64(tmpInt)
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Int64", space, string(p.rest[:8]))
	}
	// Put data before " " into Uint8 with limited to 8 symbols boundary lookup
	if len(p.rest) < 8 {
		return false, fmt.Errorf("Requested lookup in first 8 symbols to bound value for Uint8 of the rest while only %d left", len(p.rest))
	}
	if pos = bytes.Index(p.rest[:8], space); pos >= 0 {
		tmp = p.rest[:pos]
		if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 8); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as uint8 for field \033[1mUint8\033[0m: %s", string(tmp), err)
		}
		p.Uint8 = uint8(tmpUint)
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint8", space, string(p.rest[:8]))
	}
	// Put data before " " into Uint16 with limited to 8 symbols boundary lookup
	if len(p.rest) < 8 {
		return false, fmt.Errorf("Requested lookup in first 8 symbols to bound value for Uint16 of the rest while only %d left", len(p.rest))
	}
	if pos = bytes.Index(p.rest[:8], space); pos >= 0 {
		tmp = p.rest[:pos]
		if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 16); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as uint16 for field \033[1mUint16\033[0m: %s", string(tmp), err)
		}
		p.Uint16 = uint16(tmpUint)
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint16", space, string(p.rest[:8]))
	}
	// Put data before " " into Uint32 with limited to 8 symbols boundary lookup
	if len(p.rest) < 8 {
		return false, fmt.Errorf("Requested lookup in first 8 symbols to bound value for Uint32 of the rest while only %d left", len(p.rest))
	}
	if pos = bytes.Index(p.rest[:8], space); pos >= 0 {
		tmp = p.rest[:pos]
		if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as uint32 for field \033[1mUint32\033[0m: %s", string(tmp), err)
		}
		p.Uint32 = uint32(tmpUint)
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint32", space, string(p.rest[:8]))
	}
	// Put data before " " into Uint64 with limited to 8 symbols boundary lookup
	if len(p.rest) < 8 {
		return false, fmt.Errorf("Requested lookup in first 8 symbols to bound value for Uint64 of the rest while only %d left", len(p.rest))
	}
	if pos = bytes.Index(p.rest[:8], space); pos >= 0 {
		tmp = p.rest[:pos]
		if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as uint64 for field \033[1mUint64\033[0m: %s", string(tmp), err)
		}
		p.Uint64 = uint64(tmpUint)
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint64", space, string(p.rest[:8]))
	}
	// Put data before " " into Float32 with limited to 8 symbols boundary lookup
	if len(p.rest) < 8 {
		return false, fmt.Errorf("Requested lookup in first 8 symbols to bound value for Float32 of the rest while only %d left", len(p.rest))
	}
	if pos = bytes.Index(p.rest[:8], space); pos >= 0 {
		tmp = p.rest[:pos]
		if tmpFloat, err = strconv.ParseFloat(*(*string)(unsafe.Pointer(&tmp)), 32); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as float32 for field \033[1mFloat32\033[0m: %s", string(tmp), err)
		}
		p.Float32 = float32(tmpFloat)
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Float32", space, string(p.rest[:8]))
	}
	// Put data before " " into Float64 with limited to 8 symbols boundary lookup
	if len(p.rest) < 8 {
		return false, fmt.Errorf("Requested lookup in first 8 symbols to bound value for Float64 of the rest while only %d left", len(p.rest))
	}
	if pos = bytes.Index(p.rest[:8], space); pos >= 0 {
		tmp = p.rest[:pos]
		if tmpFloat, err = strconv.ParseFloat(*(*string)(unsafe.Pointer(&tmp)), 64); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as float64 for field \033[1mFloat64\033[0m: %s", string(tmp), err)
		}
		p.Float64 = float64(tmpFloat)
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Float64", space, string(p.rest[:8]))
	}
	// Put data before " " into String with limited to 8 symbols boundary lookup
	if len(p.rest) < 8 {
		return false, fmt.Errorf("Requested lookup in first 8 symbols to bound value for String of the rest while only %d left", len(p.rest))
	}
	if pos = bytes.Index(p.rest[:8], space); pos >= 0 {
		p.String = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field String", space, string(p.rest[:8]))
	}
	return true, nil
}

// Parse autogenerated method of decodersBoundedStringStress
func (p *decodersBoundedStringStress) Parse(line []byte) (bool, error) {
	var err error
	var pos int
	var tmp []byte
	var tmpFloat float64
	p.rest = line

	// Put data before " " into Float64 with limited to 8..16 symbol range boundary lookup
	if len(p.rest) < 16 {
		return false, fmt.Errorf("Requested lookup in first 16 symbols to bound value for Float64 of the rest while only %d left", len(p.rest))
	}
	if pos = bytes.Index(p.rest[8:16], space); pos >= 0 {
		tmp = p.rest[:8+pos]
		if tmpFloat, err = strconv.ParseFloat(*(*string)(unsafe.Pointer(&tmp)), 64); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as float64 for field \033[1mFloat64\033[0m: %s", string(tmp), err)
		}
		p.Float64 = float64(tmpFloat)
		p.rest = p.rest[pos+8+len(space):]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Float64", space, string(p.rest[8:16]))
	}
	return true, nil
}

// Parse autogenerated method of decoderOptionals
func (p *decoderOptionals) Parse(line []byte) (bool, error) {
	var err error
	var pos int
	var tmp []byte
	var tmpInt int64
	p.rest = line

	// Put data before ' ' into Int8
	if pos = bytes.IndexByte(p.rest, ' '); pos >= 0 {
		tmp = p.rest[:pos]
		if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 8); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as int8 for field \033[1mInt8\033[0m: %s", string(tmp), err)
		}
		p.Int8 = int8(tmpInt)
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	// Checks if the rest starts with "head=" and pass it
	if bytes.HasPrefix(p.rest, headEq) {
		p.rest = p.rest[len(headEq):]
	} else {
		p.Head.Valid = false
		goto headLabel
	}
	// Put data before ' ' into Head.Data
	if pos = bytes.IndexByte(p.rest, ' '); pos >= 0 {
		p.Head.Data = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		p.Head.Valid = false
		goto headLabel
	}
	p.Head.Valid = true
headLabel:

	// Checks if the rest starts with "end" and pass it
	if bytes.HasPrefix(p.rest, end) {
		p.rest = p.rest[len(end):]
	} else {
		return false, nil
	}
	return true, nil
}

// Parse autogenerated method of decoderOptionalsStress
func (p *decoderOptionalsStress) Parse(line []byte) (bool, error) {
	var err error
	var pos int
	var tmp []byte
	var tmpInt int64
	p.rest = line

	// Put data before ' ' into Int8
	if pos = bytes.IndexByte(p.rest, ' '); pos >= 0 {
		tmp = p.rest[:pos]
		if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 8); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as int8 for field \033[1mInt8\033[0m: %s", string(tmp), err)
		}
		p.Int8 = int8(tmpInt)
		p.rest = p.rest[pos+1:]
	} else {
		return false, fmt.Errorf("Cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Int8", ' ', string(p.rest))
	}
	// Checks if the rest starts with "head=" and pass it
	if bytes.HasPrefix(p.rest, headEq) {
		p.rest = p.rest[len(headEq):]
	} else {
		p.Head.Valid = false
		goto headLabel
	}
	// Put data before ' ' into Head.Data
	if pos = bytes.IndexByte(p.rest, ' '); pos >= 0 {
		p.Head.Data = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		p.Head.Valid = false
		goto headLabel
	}
	p.Head.Valid = true
headLabel:

	// Checks if the rest starts with "end" and pass it
	if bytes.HasPrefix(p.rest, end) {
		p.rest = p.rest[len(end):]
	} else {
		return false, fmt.Errorf("The rest (\033[1m%s\033[0m) doesn't start with `\033[1m%s\033[0m`", string(p.rest), end)
	}
	return true, nil
}

// Parse autogenerated method of decoderBranching
func (p *decoderBranching) Parse(line []byte) (bool, error) {
	var pos int
	var tmp []byte
	p.rest = line

	// Checks if the rest starts with "start " and pass it if matched
	if bytes.HasPrefix(p.rest, startSpace) {
		p.rest = p.rest[len(startSpace):]
	}
	// Checks if the rest starts with "head=" and pass it if matched
	if bytes.HasPrefix(p.rest, headEq) {
		p.rest = p.rest[len(headEq):]
	}
	// Put data before ' ' into Head.Data if found otherwise take to the end
	if pos = bytes.IndexByte(p.rest, ' '); pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		tmp = p.rest
		p.rest = p.rest[len(p.rest):]
	}
	p.Head.Data = tmp
	p.Head.Valid = true

	return true, nil
}

// Parse autogenerated method of decoderBranchingStress
func (p *decoderBranchingStress) Parse(line []byte) (bool, error) {
	var pos int
	var tmp []byte
	p.rest = line

	// Checks if the rest starts with "start " and pass it if matched
	if bytes.HasPrefix(p.rest, startSpace) {
		p.rest = p.rest[len(startSpace):]
	}
	// Checks if the rest starts with "head=" and pass it if matched
	if bytes.HasPrefix(p.rest, headEq) {
		p.rest = p.rest[len(headEq):]
	}
	// Put data before ' ' into Head.Data if found otherwise take to the end
	if pos = bytes.IndexByte(p.rest, ' '); pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		tmp = p.rest
		p.rest = p.rest[len(p.rest):]
	}
	p.Head.Data = tmp
	p.Head.Valid = true

	return true, nil
}

// GetHeadData retrieves optional value for HeadData.Name
func (p *decoderOptionals) GetHeadData() (res []byte) {
	if !p.Head.Valid {
		return
	}
	return p.Head.Data
}

// GetHeadData retrieves optional value for HeadData.Name
func (p *decoderOptionalsStress) GetHeadData() (res []byte) {
	if !p.Head.Valid {
		return
	}
	return p.Head.Data
}

// GetHeadData retrieves optional value for HeadData.Name
func (p *decoderBranching) GetHeadData() (res []byte) {
	if !p.Head.Valid {
		return
	}
	return p.Head.Data
}

// GetHeadData retrieves optional value for HeadData.Name
func (p *decoderBranchingStress) GetHeadData() (res []byte) {
	if !p.Head.Valid {
		return
	}
	return p.Head.Data
}
