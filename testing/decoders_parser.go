/* This file was autogenerated via
-----------------------------------------
 ldetool generate --code-source ../generator/gogen/template_data --package ldetesting parsing.scripts
-----------------------------------------
do not touch it with bare hands!
*/

package ldetesting

import (
	"bytes"
	"fmt"
	"strconv"
	"unsafe"
)

type decoders struct {
	rest    []byte
	Int8    int8
	Int16   int16
	Int32   int32
	Int64   int64
	Uint8   uint8
	Uint16  uint16
	Uint32  uint32
	Uint64  uint64
	Float32 float32
	Float64 float64
	String  []byte
}

func (p *decoders) Parse(line []byte) (bool, error) {
	var err error
	var pos int
	var tmp []byte
	var tmpFloat float64
	var tmpInt int64
	var tmpUint uint64
	p.rest = line

	// Put data before ' ' into Int8
	if pos = bytes.IndexByte(p.rest, ' '); pos >= 0 {
		tmp = p.rest[:pos]
		if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 8); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as int8 for field \033[1mInt8\033[0m: %s", string(tmp), err)
		}
		p.Int8 = int8(tmpInt)
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	// Put data before ' ' into Int16
	if pos = bytes.IndexByte(p.rest, ' '); pos >= 0 {
		tmp = p.rest[:pos]
		if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 16); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as int16 for field \033[1mInt16\033[0m: %s", string(tmp), err)
		}
		p.Int16 = int16(tmpInt)
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	// Put data before ' ' into Int32
	if pos = bytes.IndexByte(p.rest, ' '); pos >= 0 {
		tmp = p.rest[:pos]
		if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as int32 for field \033[1mInt32\033[0m: %s", string(tmp), err)
		}
		p.Int32 = int32(tmpInt)
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	// Put data before ' ' into Int64
	if pos = bytes.IndexByte(p.rest, ' '); pos >= 0 {
		tmp = p.rest[:pos]
		if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as int64 for field \033[1mInt64\033[0m: %s", string(tmp), err)
		}
		p.Int64 = int64(tmpInt)
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	// Put data before ' ' into Uint8
	if pos = bytes.IndexByte(p.rest, ' '); pos >= 0 {
		tmp = p.rest[:pos]
		if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 8); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as uint8 for field \033[1mUint8\033[0m: %s", string(tmp), err)
		}
		p.Uint8 = uint8(tmpUint)
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	// Put data before ' ' into Uint16
	if pos = bytes.IndexByte(p.rest, ' '); pos >= 0 {
		tmp = p.rest[:pos]
		if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 16); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as uint16 for field \033[1mUint16\033[0m: %s", string(tmp), err)
		}
		p.Uint16 = uint16(tmpUint)
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	// Put data before ' ' into Uint32
	if pos = bytes.IndexByte(p.rest, ' '); pos >= 0 {
		tmp = p.rest[:pos]
		if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as uint32 for field \033[1mUint32\033[0m: %s", string(tmp), err)
		}
		p.Uint32 = uint32(tmpUint)
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	// Put data before ' ' into Uint64
	if pos = bytes.IndexByte(p.rest, ' '); pos >= 0 {
		tmp = p.rest[:pos]
		if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as uint64 for field \033[1mUint64\033[0m: %s", string(tmp), err)
		}
		p.Uint64 = uint64(tmpUint)
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	// Put data before ' ' into Float32
	if pos = bytes.IndexByte(p.rest, ' '); pos >= 0 {
		tmp = p.rest[:pos]
		if tmpFloat, err = strconv.ParseFloat(*(*string)(unsafe.Pointer(&tmp)), 32); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as float32 for field \033[1mFloat32\033[0m: %s", string(tmp), err)
		}
		p.Float32 = float32(tmpFloat)
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	// Put data before ' ' into Float64
	if pos = bytes.IndexByte(p.rest, ' '); pos >= 0 {
		tmp = p.rest[:pos]
		if tmpFloat, err = strconv.ParseFloat(*(*string)(unsafe.Pointer(&tmp)), 64); err != nil {
			return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as float64 for field \033[1mFloat64\033[0m: %s", string(tmp), err)
		}
		p.Float64 = float64(tmpFloat)
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	// Put data before ' ' into String
	if pos = bytes.IndexByte(p.rest, ' '); pos >= 0 {
		p.String = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	return true, nil
}
