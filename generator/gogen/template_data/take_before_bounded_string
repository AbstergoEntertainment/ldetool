
// Put data before {{ .ConstValue }} into {{ .Dest }} with limited to {{.Lower}}..{{.Upper}} symbol range boundary lookup
if len({{.Rest}}) < {{.Upper}} {
{{if .Namespace}}p.{{.Namespace}}.Valid = false; goto {{.ScopeLabel}}{{else}}return false, {{ if.Serious }}fmt.Errorf("Requested lookup in first {{.Upper}} symbols to bound value for {{.Dest}} of the rest while only %d left", len({{.Rest}})){{else}}nil{{end}};{{end}}
}
if pos = bytes.Index({{.Rest}}[{{.Lower}}:{{.Upper}}], {{ .ConstName }}); pos >= 0 {
   {{ if .UseTmp }}tmp = {{.Rest}}[:{{.Lower}}+pos]
     {{ call .Decoder "tmp"  .Dest }}{{else}} {{ call .Decoder ( printf "%s[:%d+pos]" .Rest .Lower )  .Dest }}{{end}}
  {{.Rest}} = {{.Rest}}[pos+{{.Lower}}+len({{.ConstName}}):]
} else {
{{if .Namespace}}p.{{.Namespace}}.Valid = false; goto {{.ScopeLabel}}{{else}}return false, {{ if .Serious }}fmt.Errorf("Cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field {{.Dest}}", {{.ConstName}}, string({{.Rest}}[{{.Lower}}:{{.Upper}}])){{else}}nil{{end}};{{end}}
}