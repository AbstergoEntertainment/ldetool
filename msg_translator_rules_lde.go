
/*
 This file was autogenerated via
 --------------------------------------------------------
 ldetool generate --package main msg_translator_rules.lde
 --------------------------------------------------------
 do not touch it with bare hands!
*/

package main

import (
	"fmt"
	"strconv"
	"unsafe"
)

// Orig ...
type Orig struct {
	rest    []byte
	Line    int32
	Column  int32
	Message []byte
}

// Extract ...
func (p *Orig) Extract(line []byte) (bool, error) {
	p.rest = line
	var err error
	var pos int
	var tmp []byte
	var tmpInt int64

	// Checks if the rest starts with `"line "` and pass it
	if len(p.rest) >= 5 && *(*uint64)(unsafe.Pointer(&p.rest[0]))&1099511627775 == 139140688236 {
		p.rest = p.rest[5:]
	} else {
		return false, nil
	}

	// Take until ':' as Line(int32)
	pos = -1
	for i, char := range p.rest {
		if char == ':' {
			pos = i
			break
		}
	}
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Line = int32(tmpInt)

	// Take until ' ' as Column(int32)
	pos = -1
	for i, char := range p.rest {
		if char == ' ' {
			pos = i
			break
		}
	}
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Column = int32(tmpInt)

	// Take the rest as Message(string)
	p.Message = p.rest
	p.rest = p.rest[len(p.rest):]
	return true, nil
}
